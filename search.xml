<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序踩坑总结]]></title>
    <url>%2F2020%2F03%2F27%2Ffuckwechat%2F</url>
    <content type="text"><![CDATA[最近做了很多小程序相关的开发，可以说全是血泪史，顺便总结一下里面遇到的坑此页面写于小程序基础库2.10.1版本 1.app.globalData在页面启动时，有概率取不到其中的数据，虽然在文档中这个是全局变量，处于整个生命周期中，使用时需要注意 2.页面栈小程序页面栈不能超过10个，不能手动删除页面栈，这就导致页面路由复杂的小程序会出现正常路由导航失败解决办法就是使用wx.reLaunch重启小程序清空或者使用wx.navigateBack回退页面除此之外就没有别的方法了 3.小程序生命周期与页面的生命周期这是小程序最大的坑，所有的大坑都和这个有关（此处省略问候张小龙的N多脏话）在文档中你可能以为小程序从启动到看到首页是有规律的生命周期那你就大错特错了。首先小程序级别的onLaunch事件，不一定会第一时间触发，可能当页面已经展示了还没有触发。。（巨坑，许多依赖这个事件的逻辑都有大坑）第二是小程序的onReady事件不一定会准确触发，虽然写作ready，实际页面可能还没准备好就触发了，这就造成了有些需要系统api的操作失败。。第三是根据第二个引出来的，很多小程序的api是不能直接使用的，如果贸然放在小程序或者页面的启动生命周期函数中，就会直接失败，而且不会报任何错误。。（我TM）第四是小程序级别的onLaunch事件再不同手机下要触发的条件不一样，有时候你以为关掉了小程序的进程，实际上并没有，这个事件也不会触发，会引来不必要的烦恼 4.canvas相关api罄竹难书，问题太多，实在不想一一列举，全都是坑，能不碰就不碰 5.css动画各种兼容问题，以及transition不能使用，animation失效等等，解决办法就是能不用就不用 6.授权相关视频授权，昵称手机号授权要做好失败处理，同时要表现的不能太流氓，并且在过审时能低调就低调，否则会被打回（这一点我是真无语，给了权限让我们使用，又会以收集用户隐私为由打回，微信脑子有水？） 7.首页登录因为产品设计时的原因，可能在小程序启动时就让用户进入登录页面，抱歉这是不被微信允许的，在审核过程中会被打回 8.本地存储文档上说，删除小程序时本地存储也会被删除，在测试中发现并不靠谱，不一定会被删除另一方面，已存储的值不一定会被覆盖 9.保持亮屏代码文档写的非常简单，越简单问题越多，不一定会起作用，开发者可以直接搞个定时器循环执行 10.Websocket全是问题，全是问题，在生成一个链接后，返回的实例里面会有个属性，显示链接状态，不要相信！不要相信！文档没写就不是稳定的！不要用！一点也不稳定！ 最后总结小程序的坑一直都非常的多，即使它已经出来很多年了 不完善的文档，很多只给了一点用法，需要注意的事项不会写，用了才遇到的很多坑 令人无语的报错，有时候小程序会报莫名其妙的错，有时候有些api明明有错却什么都不报，让人摸不到头脑，不清楚哪里有错 让人无法相信的api，永远不要完全相信文档里面的描述，多看看下面的bug反馈 不同平台不同的bug，你真的需要2到3部安卓机和一个苹果机，它们的表现可能都会不一样 这一次只总结一些临时想到的问题，以后还会更新这篇文章。真心希望张小龙能收起它的傲慢，好好打磨他的产品，大部分人用微信是因为它的垄断，被裹挟着使用，并不代表微信是一个好产品，微信的各种使用问题体验问题，它的落后已经不是少部分人抱怨了，可能这对于微信来说只是一个稻草，但也可能是压死微信这个骆驼的最后一根稻草。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWA初尝试]]></title>
    <url>%2F2019%2F11%2F21%2FPWA%2F</url>
    <content type="text"><![CDATA[PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。具体的介绍，以及详细的教程，请看这里，我在这里就不在重复造轮子了这里我就简单的介绍下我在本博客网站下搭建PWA的具体步骤，让同学们按照我最简单的教程来个快速启动 注意事项想要成功搭建并运行一个完整的PWA应用，你需要以下几个条件： 站点部署 manifest.json，该文件需配置如下属性： short_name （用于主屏幕显示） name （用于安装横幅显示） icons （其中必须包含一个 mime 类型为 image/png 的图标声明） start_url （应用启动地址） display （必须为 standalone 或 fullscreen） 站点注册 Service Worker。 站点支持 HTTPS 访问（或者在本地环境127.0.0.1或localhost下）。 站点在同一浏览器中被访问至少两次，两次访问间隔至少为 5 分钟。ServiceWorker.js安装首先在主页html上注册ServiceWorker.js123456789101112131415if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function () &#123; navigator.serviceWorker.register('/sw.js', &#123;scope: '/'&#125;) .then(function (registration) &#123; // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;) .catch(function (err) &#123; // 注册失败:( console.log('ServiceWorker registration failed: ', err); &#125;); &#125;);&#125; 在sw.js中的内容是这样的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var version = '1.0.3'; //手动更新版本// 安装阶段跳过等待，直接进入 activethis.addEventListener('install', function (event) &#123; event.waitUntil(this.skipWaiting());&#125;);this.addEventListener('activate', function (event) &#123; event.waitUntil( Promise.all([ // 更新客户端 this.clients.claim(), // 清理旧版本 caches.keys().then(function (cacheList) &#123; return Promise.all( cacheList.map(function (cacheName) &#123; if (cacheName !== ('cache-v-' + version)) &#123; return caches.delete(cacheName); &#125; &#125;) ); &#125;) ]) );&#125;);this.addEventListener('fetch', function (event) &#123; event.respondWith( caches.match(event.request).then(function (response) &#123; // 来来来，代理可以搞一些代理的事情 // 如果 Service Worker 有自己的返回，就直接返回，减少一次 http 请求 if (response) &#123; return response; &#125; // 如果 service worker 没有返回，那就得直接请求真实远程服务 var request = event.request.clone(); // 把原始请求拷过来 return fetch(request).then(function (httpRes) &#123; // http请求的返回已被抓到，可以处置了。 // 请求失败了，直接返回失败的结果就好了。。 if (!httpRes || httpRes.status !== 200) &#123; return httpRes; &#125; // 不缓存loadServiceWork.js文件 if (httpRes.url.indexOf('loadServiceWork.js')&gt;=0)&#123; return httpRes; &#125; // 不缓存sw.js文件 if (httpRes.url.indexOf('sw.js')&gt;=0)&#123; return httpRes; &#125; // 请求成功的话，将请求缓存起来。 var responseClone = httpRes.clone(); caches.open('cache-v-' + version).then(function (cache) &#123; cache.put(event.request, responseClone); &#125;); return httpRes; &#125;); &#125;) );&#125;); 设置manifest.json文件首先在主页html文件下引入manifest.json文件1&lt;link rel="manifest" href="/manifest.json"&gt; manifest.json文件中内容的填写123456789101112131415161718192021222324&#123; "short_name": "Jackfred", "name": "Jackfred的博客", "icons": [ &#123; "src": "/favicon96.png", "type": "image/png", "sizes": "96x96" &#125;, &#123; "src": "/favicon144.png", "type": "image/png", "sizes": "144x144" &#125;, &#123; "src": "/favicon188.png", "type": "image/png", "sizes": "188x188" &#125; ], "display": "minimal-ui", "theme_color": "black", "start_url": "index.html"&#125; 到这里，PWA的部署就结束了，为了应对不同分辨率的手机，我们可能需要不同尺寸的图标，在我部署测试的时候发现，谷歌浏览器要求至少需要一个144x144尺寸的图标，请各位同学注意。 结果展示请大家用手机扫下面的二维码或者直接点击这个链接https://www.jackfred.cn/因为我站点证书是直接用的github的证书，所以，部分手机浏览器会显示证书不安全或者不是私密链接等内容，请忽略ヾ(。￣□￣)ﾂ゜゜゜根据PWA的设计原则，我们可以自己主动点击浏览器菜单页，会发现多了一个添加到主屏幕的选项，也可以分2次访问网站（间隔要5分钟以上），手机屏幕下方就会自动弹出提示安装站点的横幅，点击即可添加]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Vue3的新特性Function-api]]></title>
    <url>%2F2019%2F09%2F25%2Fvue3-function-api%2F</url>
    <content type="text"><![CDATA[最近（实际上已经几个月了）vue社区关于vue3的新特性一事一直闹得沸沸扬扬的，我因为公司以及家庭原因已经好久没有更博了（咕咕咕），最近了解了一下相关的内容，现在简单的解释一下Vue3的这个新特性，以及为什么尤雨溪大佬要力排众议坚持这么做。在这里先贴一下官方对此的解释，英语好的同学可以直接看这个，解释的更详细。懒得看的同学继续听我说。 起因React在近期做出了一个重大更新React Hooks，在这个更新中React提出了一个重要的解决方案（或者说编码思维？），然后众所周知，Vue一直是一个能够吸取Angular和React等优秀框架优点，博众人之长的框架。所以尤雨溪大佬就再次也跟进吸取了这个特性。 React Hooks提出了什么思想？简单来说，就是因为React的运行机制（生命周期思想），改变了我们传统的编写组件逻辑的方式。想要实现一个效果，我们可能需要把一个有完整逻辑的操作拆分放到不同的生命周期函数中。例如我们经常会在componentDidMount函数中监听事件，然后在componentWillUnmount函数中清楚监听。这样的写法，拆分了一个完整的组件逻辑，并把这些拆分掉的逻辑与其他逻辑放在了一起，对于代码的可读性上以及理解上变得更加难懂，组件之间的状态逻辑也难以复用。 基于此原因，在加上React官方对国际标准中class一直都没有没有稳定的语法提案的失望，所以打算采取渐进策略，开始关注并加入Function-api模式 Function-api模式主要的变化是什么？在vue3中，提供了一个setup函数，在这个函数中，你可以把所有的组件逻辑都写在这里，而不用想以前一样，需要把状态放在data函数，相关逻辑放在生命周期函数等等。一下是官方的一个例子：12345678910111213141516171819202122232425function useMouse() &#123; const x = value(0) const y = value(0) const update = e =&gt; &#123; x.value = e.pageX y.value = e.pageY &#125; onMounted(() =&gt; &#123; window.addEventListener('mousemove', update) &#125;) onUnmounted(() =&gt; &#123; window.removeEventListener('mousemove', update) &#125;) return &#123; x, y &#125;&#125;// in consuming componentconst Component = &#123; setup() &#123; const &#123; x, y &#125; = useMouse() const &#123; z &#125; = useOtherLogic() return &#123; x, y, z &#125; &#125;, template: `&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`&#125; 组件数据value(0)来存取，生命周期函数也直接在setup函数中执行了，对应vue2中的一些特性比如watch也提供了函数式的表达。这其中还有一些细节变化，我们不做详细讨论。 在这里可以做个简单的概括，vue2中我们的书写方式叫option-api，在vue3中，这些类似的属性配置都提供了函数式的书写方式，这就是Function-api。 这样不会让开发代码变得更加混乱了吗？以下是官方对此的解释的大概翻译（英文水平有限，只做概括翻译）： 我收到一些反馈，他们觉得新手会在这个模式下写出意大利面条式的代码，我认为这些担忧是毫无根据的，Function-api模式确实比以往的模式更加的灵活，但是Function-api模式可以把你的组件逻辑写在一个封密的函数中，传统的模式会把你的组件逻辑分到props 、data()、mounted等属性中，如果你把这个组件放到你的app中，他将会变成一个怪物，组件的逻辑像碎片一样散布在每个角落，而Function-api模式则把这些逻辑组织在setup函数中，避免了这种问题发生。 原文链接在这，大概意思就是这样，虽然我觉得尤雨溪大佬并没有直面回答问题。。。 这个模式是不是意味着如果我要升级我的项目，就要改写代码？不是，Function-api是向上兼容的，是一个可选选项，从vue2升级到vue3不需要改写任何代码。 那会一直保持这种兼容吗？目前会（言下之意就是未来不会），至少在这篇RFC文档中 结语拥抱未来总归是一件好事，作为一个优秀的框架，必然要跟上最新的技术和思想（虽然他越来越像React了。。），各位用惯了vue2的老程序员也不必不适应，毕竟现在前端就是这样的，还是处于变动的时代。 求求你，我实在学不动了.jpg 哈哈]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google的动画技术Flip初探]]></title>
    <url>%2F2019%2F09%2F25%2FGoogle-flip-animation%2F</url>
    <content type="text"><![CDATA[最近对Vue的&lt;transition-group&gt;的动画效果感兴趣，于是研究了一下实现原理。在官方文档中，内部的实现，是Vue 使用了一个叫 FLIP 简单的动画队列，一个来自谷歌官方的动画技术。搜了一下国内的博客，发现对其介绍非常的少（实际上就只有1篇，剩下的都是互相抄，换汤不换药）在一番摸索后，我大概了解了这个技术，下面尽量用简单的语言说一下Flip的原理和使用。 什么是Flip？简单来说，就是在css动画中，除了 transform 和 opacity 之外的动画开销都比较大（包括left、top等定位元素），动画会有一点迟滞，因为浏览器必须递归检查其他元素的布局是否因此而改变。所以Flip就是一个仅仅通过transform这个属性来实现流畅无延时的动画的技术。 Flip的实现原理简单来说，Flip就是记录一个元素变化前和变化后的状态,然后再通过js模拟重播这一动画过程，（注：Flip的技术思维还可以用作更高级的动画运用，这篇文章只探讨初级的运用）这里记录元素的状态包括元素的位置的长宽。Flip是First, Last, Invert, Play的缩写，引用一下官方对此的解释。 First 元素的初始状态。 在发生任何事情之前，记录将要过渡的元素的当前（即，first）位置和尺寸。 可以使用element.getBoundingClientRect() 来做到这一点，如下所示。 Last 执行导致过渡瞬时发生的代码，并记录元素的最后（即 last）位置和尺寸。 Invert 由于元素处于最后位置，所以我们希望通过使用transform修改其位置和尺寸来创建它处于第一位置的错觉。这需要一点数学，但不是太困难。 Play 将元素倒置（假装在第一个位置），我们可以通过将其 transform 设置为 none，将其移回到最后位置。 官方Flip使用教程因为官方没有正式的文档，只有demo和视频教程（这一点有点让人无语。。）而demo实现的效果虽然很赞，但是代码太多了，实现的复杂，对于初学者不是很友好，所以我在这里做个最简单的演示。123456789101112131415161718192021&lt;script src="https://raw.githubusercontent.com/googlearchive/flipjs/master/dist/flip.js"&gt;&lt;/script&gt;&lt;style&gt;.hide-box&#123; display: none; width: 200px; height: 200px;&#125;.flip-box&#123; width: 200px; height: 200px; font-size: 40px; line-height: 200px; text-align: center; font-weight: bold; box-shadow: 0 0 7px 1px rgba(222, 222, 222, 0.9);&#125;&lt;/style&gt;&lt;div class="content"&gt; &lt;div class="hide-box" id="hide"&gt;&lt;/div&gt; &lt;div class="flip-box" id="flip"&gt;Flip&lt;/div&gt;&lt;/div&gt; 在这里我们引入了官方的Flip.js，然后创建了两个div，一个是实验对象flip-box，还有一个在其文档流上方的隐藏div效果图：1234567891011var hidebox = document.querySelector("#hide");var flipbox = document.querySelector("#flip");let flip = new FLIP(&#123; //初始化 element: flipbox, duration: 500&#125;);flip.first(); //记录flipbox的初始状态hidebox.style.display = "block";// 能够引起flipbox位置和形状变化的操作flip.last(); //记录被挤下去的flipbox的状态flip.invert(); //还原flipbox的初始状态flip.play(); //播放动画 这里我们直接让隐藏的div显示，下面的flipbox会被挤下去，这里是效果图：我们注意到这里动画是平滑过渡过去的，可能比较单调，官方在这里预留了运动曲线函数，可以高度自定义。123456let flip = new FLIP(&#123; element: target, easing: function (t) &#123; return t * t; &#125;&#125;); 如何在react和vue中使用基于Flip的思想，我们发现实际上和现有的主流框架的生命周期思想是不谋而合的，所以使用起来也非常容易。只需要在元素初始生命周期调用Flip记录状态，在元素更新时的生命周期记录并播放即可。12345678mounted()&#123; flip.first();&#125;,updated()&#123; flip.last(); flip.invert(); flip.play();&#125; 我们也可以直接封装成一个mixin文件，这样就可以在我们需要动画的元素上一键加上动画效果。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>js动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序的知识补充和答疑]]></title>
    <url>%2F2019%2F04%2F17%2Fwechat-css%2F</url>
    <content type="text"><![CDATA[通过9节课培训的结果，了解到了部分同学还存在某些小程序相关的疑问，在这里补充一下相关的知识，以及答疑。 布局问题在这里我们主要讨论行内元素、块级元素、以及行内块级元素，元素的浮动在小程序里面会有怪异的表现，这里就不讨论了 行内元素会在一条直线上排列（默认宽度只与内容有关），都是同一行的，水平方向排列。块级元素各占据一行（默认宽度是它本身父容器的100%（和父元素的宽度一致），与内容无关），垂直方向排列。块级元素从新行开始，结束接着一个断行。行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。而行内块级元素即可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性1234&lt;text class='ha'&gt;行内元素a&lt;/text&gt;&lt;text class='hb'&gt;行内元素设置了宽高b&lt;/text&gt;&lt;view class='ka'&gt;块级元素a&lt;/view&gt;&lt;view class='kb'&gt;块级元素设置了宽高b&lt;/view&gt;&lt;view class='oa'&gt;行内块级元素a&lt;/view&gt;&lt;view class='ob'&gt;行内块级元素b&lt;/view&gt; 12345678910111213141516171819202122232425262728293031.ha&#123; color: red;&#125;.hb&#123; width: 200rpx; height: 200rpx;&#125;.ka&#123; background: red;&#125;.kb&#123; width: 200rpx; height: 200rpx; background: blue;&#125;.oa&#123; display: inline-block; width: 200rpx; height: 200rpx; background: red;&#125;.ob&#123; display: inline-block; width: 400rpx; height: 400rpx; background: blue;&#125;.ka,.kb,.oa,.ob&#123; color: white; vertical-align: top;&#125; 在上一节课，有同学问我，有时候设计图，想让一个元素居右，要怎么写，虽然小程序里面float不好用，但是想实现的方法还是有很多的，先结合本篇文章说一个方法第一种方法，通过填充的方式使元素居右12&lt;view class='a'&gt;&lt;/view&gt;&lt;view class='b'&gt;&lt;/view&gt; 123456789101112.a&#123; width: 60%; height: 50rpx; background: red; display: inline-block;&#125;.b&#123; width: 40%; height: 50rpx; background: blue; display: inline-block;&#125; 第二种，巧用行内元素的text-align属性123&lt;view class='a'&gt; &lt;view class='b'&gt;&lt;/view&gt;&lt;/view&gt; 123456789.a&#123; text-align: right;&#125;.b&#123; width: 50rpx; height: 50rpx; background: blue; display: inline-block;&#125; 第三种方法，就是使用flex布局实现，具体知识可以看我以前的文章flex布局123&lt;view class='a'&gt; &lt;view class='b'&gt;&lt;/view&gt;&lt;/view&gt; 123456789.a&#123; display: flex; justify-content: flex-end;&#125;.b&#123; width: 50rpx; height: 50rpx; background: blue;&#125; this指向问题在小程序中，全局环境下，this指向的是undefined（与js不同）当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。12345678var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // logs 37 当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象。123456789function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16 想了解更多关于this的知识，可以看看我以前的文章：js的继承 wxs用法这是对于小程序方面知识介绍的最后一点补充wxs是在小程序中一个比较鸡肋的功能（个人见解），其作用就是可以让你在wxml文件中插入js脚本，js脚本需要统一的通过module.exports来输出一个对象或者值。在后面的代码中则可以调用它。12345678&lt;wxs module="test"&gt;module.exports = &#123; test:function(a)&#123; return a + ' test'; &#125;&#125;&lt;/wxs&gt;&lt;view&gt;&#123;&#123;test.test(data)&#125;&#125;&lt;/view&gt; 这个功能不能从上下文中获取页面的数据，只能内部自定义一些数据，使用上和声明一个函数没什么区别，而且插在wxml文件中还会增加代码的混乱度，所以我觉得是个比较鸡肋的功能，但是在微信小程序官方文档里，它依旧给了不少的篇幅介绍，所以我在这里补充一下。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序的登录与分享]]></title>
    <url>%2F2019%2F04%2F11%2Fminiprogram-share-and-login%2F</url>
    <content type="text"><![CDATA[登录从微信官方给的文档上给的图看，有点复杂，让人头昏眼花，实际上我们只要理清流程，整个过程并不难。 首先需要调用微信的登录接口，拿到code12345678910wx.login(&#123; success(res) &#123; if (res.code) &#123; // 发起网络请求 console.log(res.code) &#125; else &#123; console.log('登录失败！' + res.errMsg) &#125; &#125;&#125;) 然后发送code里的数据到对应的后台123456789wx.request(&#123; url: 'loginurl', //你对应后台的登录地址 data: &#123; code: res.code &#125;, success:function()&#123; callback(); &#125;&#125;) 后台拿到数据与微信后台交互解密，返回解密数据123456&#123; "openid" : "otsAA5dH45UrTJaBXi-tOemf1-dg", "user_3rdsession" : "a85d4520e4df47f139c7dd718c179df9", "status":"normal" //第三方后台自定义状态数据&#125; 小程序拿到数据，存入localstorage123456wx.setStorageSync( 'userInfo', &#123; data:'data' &#125;) 封装网络请求函数，在每次发送请求时，使用getStorageSync取出数据，带上数据发送出去，小程序设置用户在没有操作的情况下session过5分钟就会过期，所以需要处理好过期情况123456789101112131415161718192021222324252627282930function ajax_curl(url, data, cb, posttype = 'get', func_fail)&#123; var userInfo = wx.getStorageSync('userInfo'); data = Object.assign(data, userInfo); //合并对象 wx.request(&#123; url: url, data: data, // method: method_type, 忽略细节 // header: &#123; // 'Content-Type': headerset // &#125;, success: function (res) &#123; typeof cb == "function" &amp;&amp; cb(res.data.data); &#125;, fail: function (res) &#123; if (res.data.code == -999) &#123; //检测下线，重新登录 login(function()&#123; data.user_3rdsession = wx.getStorageSync('userInfo').user_3rdsession ajax_curl(url, data, cb, posttype); &#125;); &#125; else &#123; typeof func_fail == "function" &amp;&amp; func_fail(res); wx.showToast(&#123; title: res.message, icon: 'none', duration: 2000 &#125;) &#125; &#125; &#125;)&#125; 分享小程序的分享有两种形式，一个是通过按钮button转发，一个是通过右上角的菜单按钮转发。按钮转发需要设置button组件中的open-type属性，此处需要页面设置Page.onShareAppMessage事件才能出发1&lt;button open-type="share"&gt;分享&lt;/button&gt; 菜单转发就简单很多，只需要在当前页里设置好onShareAppMessage事件12345678910111213Page(&#123; onShareAppMessage(res) &#123; if (res.from === 'button') &#123; // 来自页面内转发按钮,如果是来自菜单则是menu console.log(res.target) &#125; return &#123; title: '自定义转发标题', path: '/page/user?id=123', imageUrl:'' //可选 &#125; &#125;&#125;) 在微信开发者编辑器中模拟打开分享小程序的场景选择好启动页面，为你分享的那个页面路径，设置好你的启动参数，就可以模拟分享小程序的场景 获取群内转发的一些信息shareTicket首先需要使用微信的接口开放shareTicket的设置123wx.showShareMenu(&#123; withShareTicket: true&#125;) 在转发的过程中，其他用户打开转发的小程序时，可以通过在 App.onLaunch 或 App.onShow 获取到一个 shareTicket12345App(&#123; onLaunch: function (opt) &#123; console.log(opt.shareTicket) //一个字符串 &#125;&#125;) 注意，这里可以用我们刚刚学到的知识来模拟分享场景，不过有一个小小的区别，看下图然后通过调用 wx.getShareInfo 接口传入此 shareTicket 可以获取到转发信息123456wx.getShareInfo(&#123; shareTicket: app.globalData.tik, success:function(res)&#123; console.log(res) &#125;&#125;) 此处获取到的数据，实际上是包含加密字符串的对象，我们还需要将数据发送到对应的第三方服务器中解密，才能拿到正常的数据123456789&#123; "nickName": "Band", "gender": 1, "language": "zh_CN", "city": "Guangzhou", "province": "Guangdong", "country": "CN", "avatarUrl": "http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"&#125;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2019%2F01%2F22%2Fflex-mobile%2F</url>
    <content type="text"><![CDATA[Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 容器的属性flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 容器成员的属性order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该属性可能取6个值，除了auto，其他都与align-items属性完全一致。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 最后的例子和说明flex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况： auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。1234567891011121314151617181920212223242526272829&lt;div class="parent"&gt; &lt;div class="item-1"&gt;&lt;/div&gt; &lt;div class="item-2"&gt;&lt;/div&gt; &lt;div class="item-3"&gt;&lt;/div&gt;&lt;/div&gt; &lt;style type="text/css"&gt; .parent &#123; display: flex; width: 600px; &#125; .parent &gt; div &#123; height: 100px; &#125; .item-1 &#123; width: 140px; flex: 2 1 0%; background: blue; &#125; .item-2 &#123; width: 100px; flex: 2 1 auto; background: darkblue; &#125; .item-3 &#123; flex: 1 1 200px; background: lightblue; &#125;&lt;/style&gt; 主轴上父容器总尺寸为 600px子元素的总基准值是：0% + auto + 200px = 300px，其中 0% 即 0 宽度 auto 对应取主尺寸即 100px 故剩余空间为 600px - 300px = 300px伸缩放大系数之和为： 2 + 2 + 1 = 5剩余空间分配如下： item-1 和 item-2 各分配 2/5，各得 120px item-3 分配 1/5，得 60px 各项目最终宽度为： item-1 = 0% + 120px = 120px item-2 = auto + 120px = 220px item-3 = 200px + 60px = 260px 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发教程（一）]]></title>
    <url>%2F2019%2F01%2F16%2Fmobile-develop-teach%2F</url>
    <content type="text"><![CDATA[第一节课我们主要是讲解移动端前端开发viewport相关的概念和搭建基础 viewport的概念在平常pc端开发的过程中，我们根据设计师给出的设计稿，按照设计稿里面每个元素的大小，在页面上用px这个单位按原样用css画出来，这在pc端开发是在正常不过的事，但是在手机上的移动端开发，我们却并不能这样。下面是一个例子。1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Test01&lt;/title&gt;&lt;style&gt; *&#123;margin: 0;padding: 0&#125; .pic&#123; width: 640px; height: 1136px; background-color: #FFE872; color: white; font-size: 150px; text-align: center; line-height: 1136px; font-family: cursive; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="pic"&gt; Yellow &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Iphone5手机的分辨率为640x1136，我们在这个页面中用css画出了一个像素为640x1136的黄色方块，按照直觉在手机上应该满屏显示。但是实际效果不是这样，如下图。我们看到黄色方块没有预想的那样占满整个屏幕。原因是什么呢？ 移动端1px并不等于设备的1px在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。 但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。 在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。 其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。 在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。下图为devicePixelRatio的兼容性在各个手机浏览器上的表现 利用viewport对手机缩放进行控制关于viewport已经有大神对此有详细的研究（第一篇，第二篇，第三篇），有兴趣的同学可以去看一下 我在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我的head标签中1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。 meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：123456width 设置layout viewport 的宽度，为一个正整数，或字符串&quot;device-width&quot;initial-scale 设置页面的初始缩放值，为一个数字，可以带小数minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数height 设置layout viewport 的高度，这个属性对我们并不重要，很少使用user-scalable 是否允许用户进行缩放，值为&quot;no&quot;或&quot;yes&quot;, no 代表不允许，yes代表允许 利用rem对不同移动端进行适配看一个例子12345678.con &#123; width: 10rem; height: 10rem; background-color: red; &#125;&lt;div class="con"&gt; &lt;/div&gt; 效果图：我们在修改一下html根元素的font-size1234567891011html &#123; font-size: 25px;&#125;.con &#123; width: 10rem; height: 10rem; background-color: red; &#125;&lt;div class="con"&gt; &lt;/div&gt; 效果图：由此我们可以知道rem的特性是根据根元素的font-size值来改变自身的值，我们可以给html设定不同的值，从而达到我们css样式中的适配效果。 例如我们要是在iPhone6下写一个元素来横向占满整个屏幕，那么代码可以这么写：1234567891011html &#123; font-size: 0.5px;&#125;.con &#123; width: 750rem; height: 10rem; background-color: red; &#125;&lt;div class="con"&gt; &lt;/div&gt; 因为iPhone6的devicePixelRatio的值为2，在根据前面设置的meta，无缩放，我们可知道，在屏幕是1个物理像素为0.5个独立像素，所以设置font-size为0.5即可直接使用设计稿的尺寸。 但是这样只是适配了iPhone6，无法适配所有手机，所以在这里我们可以用js动态控制font-size1234567891011121314151617var dpr = window.devicePixelRatio,meta = document.getElementsByTagName("meta")[1];meta.setAttribute('content', 'initial-scale=' + 1 / dpr + ', maximum-scale=' + 1 / dpr + ', minimum-scale=' + 1 / dpr + ', user-scalable=no');; (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = clientWidth / 750 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 这段代码解决了几个痛点 这样就可以完全按照视觉稿上的尺寸来了。 解决了图片高清问题。 解决了border 1px问题（我们设置的1px，在iphone上，由于viewport的scale是0.5，所以就自然缩放成0.5px）]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vue在部分iPhone机型的微信浏览器中出现偶然乱码的bug]]></title>
    <url>%2F2018%2F09%2F04%2Fiphone-wechat-charset-bug%2F</url>
    <content type="text"><![CDATA[今天遇到一个诡异的bug，在部分iPhone手机下，微信访问的网页出现了乱码 其他iPhone就没有这个问题，android手机也没有 于是定位了好久的问题，最终解决了，记录下 是因为框架用的是vue，在打包部署的时候，生成的index.html文件不符合h5规范，只要把index.html文件重新手写一遍就好了 虽然问题解决了，不过还是想吐槽一句： 苹果真的很严格ヽ(ｏ`皿′ｏ)ﾉ]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe嵌套页面滚动时jQuery的offset的值不准的bug]]></title>
    <url>%2F2018%2F03%2F05%2FjqueryOffsetBug%2F</url>
    <content type="text"><![CDATA[记录一下这几天遇到的一个诡异的bug最近项目需求，要做一个气泡卡片的功能，因为不想引入新的库发生未知bug，于是自己手写了一个，定位通过jquery的offset方法来获取 项目的布局是通过iframe嵌套方式来布局的，结果发现在部分页面下，滚动后点击元素出现气泡，会发生气泡定位不准的情况 经过多次debugger后确定不是我的代码问题，于是查看jquery的源码1234567891011121314if(arguments.length) return e === t ? this : this.each(function(t) &#123; v.offset.setOffset(this, e, t) &#125;); var n, r, i, s, o, u, a, f = &#123; top: 0, left: 0 &#125;, l = this[0], c = l &amp;&amp; l.ownerDocument; if(!c) return; return(r = c.body) === l ? v.offset.bodyOffset(l) : (n = c.documentElement, v.contains(n, l) ? (typeof l.getBoundingClientRect != "undefined" &amp;&amp; (f = l.getBoundingClientRect()), i = tr(c), s = n.clientTop || r.clientTop || 0, o = n.clientLeft || r.clientLeft || 0, u = i.pageYOffset || n.scrollTop, a = i.pageXOffset || n.scrollLeft, &#123; top: f.top + u - s, left: f.left + a - o &#125;) : f) jquery中的offset的top是通过元素的getBoundingClientRect().top + window.scrollY - clientTop计算出来的。 这本来是没有什么问题的，但是上文提到过项目的整个页面是通过iframe来布局的，通过我不断的对比发现，window.scrollY在滚动的时候的值有时候会不正确，即在页面滚动的时候window.scrollY会少掉一个document.body.scrollTop的值。 我们只要在代码中加上这个值就可以修复这个bug]]></content>
      <tags>
        <tag>bug,jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配讲解]]></title>
    <url>%2F2017%2F06%2F26%2Fmobile-adaptive%2F</url>
    <content type="text"><![CDATA[从乔布斯推出智能手机以来，市面上已经有各种各样的牌子不同大小的智能手机，手机的分辨率也各有不同，同时移动互联网的发展，移动端网页技术也开始被人重视，初次接触移动端的同学曾经可能也和我一样迷茫过，在公司要求做一些移动端的网页时，没有足够的移动开发经验和基础知识，慌忙的在网上选择“阿里移动端适配方案”或者“网易移动端适配方案”，网页做完了，可是还是会迷惑为什么传统的网页在不同的手机上表现都如此不同，还有rem是什么，viewport又是什么？今天就带大家梳理一下知识点，打好基础的同时选择适合自己的开发方案。 引入问题首先我们先看这么一段代码1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Test01&lt;/title&gt;&lt;style&gt; *&#123;margin: 0;padding: 0&#125; .pic&#123; width: 640px; height: 1136px; background-color: #FFE872; color: white; font-size: 150px; text-align: center; line-height: 1136px; font-family: cursive; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="pic"&gt; Yellow &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Iphone5手机的分辨率为640x1136，我们在这个页面中用css画出了一个像素为640x1136的黄色方块，按照直觉在手机上应该满屏显示。但是实际效果不是这样，如下图。我们看到黄色方块没有预想的那样占满整个屏幕。原因是什么呢？同时我们在浏览器模拟手机时，看到工具栏上方还显示这这样一个数据为啥会显示320x568呢，还有DPR是什么？ 什么是DPR？DPR的全程是设备像素缩放比(device PixelRatio)。因为屏幕尺寸大小的相同的手机分辨率是不一样的，Iphone5的分辨率为640x1136，这就代表手机的屏幕上有640x1136个物理像素，但是屏幕尺寸320x568那么大，所以需要缩放以显示。在这里640÷320=2，同时1136÷568=2，所以DPR=2，我们一般把DPR大于等于2的屏幕称为高清屏(retina屏)。 由此可知，同样像素大小的元素在iPhone5上会缩小一倍。 进一步的疑问我们解释了DPR是什么，但是还是会有疑惑，因为从理论上来说，即使这样，黄色方块也应该占满全部屏幕啊，不应该像图片那样，既不占满屏幕，也不是屏幕大小的1/2，更不是屏幕的2倍，这就很让人疑惑。而这些呢，也牵扯到一段手机厂商的历史，在手机厂商制造手机时，考虑到自家手机可能会访问一些pc端的网页，为了有一个良好的页面体验，会默认将屏幕的宽度定为某一个默认值，然后在页面超出这个默认值的时候，又会自动缩放，让屏幕的宽度刚好可以适应整个网页。在这里我们可以做个实验，如下图从这张图上我们可以看到元素宽度在980px的时候正好占满屏幕，所以iPhone5的默认宽度是980px，而当元素宽度大于980px的时候，从元素的高度可以看出屏幕明显将元素进行了缩放已达到完整显示的目的。 如何控制浏览器缩放？可以说手机厂商自作聪明的作法(至少我是这么认为的)给很多前端开发者带来了麻烦，因为手机各自的分辨率不同，默认宽度不同，同样的页面在不同的手机上显示可能就会错位，如果用百分比做度量单位，就无法解决元素高度(高度的百分比是父元素的宽度的比例)还有边框宽度和元素定位等问题。在这里我们可以通过meta标签的viewport来控制页面缩放。123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta name="viewport" content="width=640"&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Test01&lt;/title&gt;&lt;style&gt; *&#123;margin: 0;padding: 0&#125; .pic&#123; width: 640px; height: 1136px; background-color: #FFE872; color: white; font-size: 150px; text-align: center; line-height: 1136px; font-family: cursive; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="pic"&gt; Yellow &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如图所示，我们在meta头设置了viewport的值为”width=640”，这样手机的默认宽度就定成了640px，元素正好覆盖了全部页面。可是还有缺陷，就是浏览器还是会自动缩放。这时候我们在meta表现中加入这行代码1&lt;meta name="viewport" content="width=640,maximum-scale=1, minimum-scale=1,initial-scale=1,user-scalable=no"&gt; 在这里scale的意思是缩放，maximum-scale和minimum-scale是最大缩放和最小缩放倍数，initial-scale为初始缩放倍数，user-scalable代表用户是否可以缩放。此时页面效果变成了下面这样这是因为禁止了页面缩放，而iPhone5的屏幕像素大小只有320，所以页面是屏幕的2倍，且不可缩放。如果还是需要达到我们之前满屏的目的，则需要改动viewport的width值和元素的宽度值。123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport" content="width=320,maximum-scale=1, minimum-scale=1,initial-scale=1,user-scalable=no"&gt;&lt;title&gt;Test01&lt;/title&gt;&lt;style&gt;*&#123;margin: 0;padding: 0&#125; .pic&#123; width: 320px; height: 568px; background-color: #FFE872; color: white; font-size: 50px; text-align: center; line-height: 568px; font-family: cursive; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="pic"&gt; Yellow &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样，页面就可以满屏显示了。 不同手机下显示问题通过测试我们发现，经过我们的设置黄色方块在不同的手机分辨率下保持了一样的大小，但是有一个小问题，那就是在不管页面内的元素的大小和多少的情况下，如果viewport的width设置一个固定的值，比如320，那么屏幕逻辑像素宽度小于320的手机总是可以左右滑动的，在一般情况下这些不符合我们的预期，所以我们需要给width设置一个特殊值1&lt;meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"&gt; 这样，页面的默认宽度就确定为手机逻辑像素宽度了。 什么是rem问题说到现在，似乎还没有解决，我们虽然搞定了手机的缩放问题，但是仍然无法做到让黄色方块在各个手机的分辨率下满屏显示，px在是个精确的度量单位，我们更需要一种按照手机分辨率，按比例缩放的单位！而这就是rem存在的意义，rem与我们平常所见的em单位很像，实际上多出来的这个r就是response的意思rem就是相对于页面根元素字体大小的度量单位，也就是说如果123html &#123; font-size:16px;&#125; 那么1rem = 16px，2rem = 2x16px，就是这么简单。根据这个简单的特性，我们可以通过js先算出当前手机的宽度，然后通过一个事先约定好的比例公式算出的值给html的font-size赋值。这样rem的值就是一个响应式的值了这样的代码有很多，在这里我给出一段参考代码1234567891011121314;(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 375) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 这一段代码中是将iPhone6为底稿，所有的元素的像素宽度÷20，得到的值就是元素的rem值 彻底解决问题根据前面的知识点，我们来终结之前的满屏问题，因为上述代码是已iPhone6(375x667)为底稿的，所以如果要满屏的话，黄色方块的宽应该设置为375÷20=18.75rem，高设置为667÷20=33.35rem。所以最终代码是这样的12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"&gt;&lt;title&gt;Test01&lt;/title&gt;&lt;style&gt;*&#123;margin: 0;padding: 0&#125; .pic&#123; width: 18.75rem; height: 33.35rem; background-color: #FFE872; color: white; font-size: 50px; text-align: center; line-height: 568px; font-family: cursive; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="pic"&gt; Yellow &lt;/div&gt;&lt;script type="text/javascript"&gt; ;(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 375) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下 另一种办法——网易的移动端适配方案我们之前说过，如果给viewport的width设置一个固定值，则在不同分辨率下手机会进行自动缩放以适应屏幕，如果我们可以使用js计算出缩放比例，让手机屏幕正好是我们需要的固定值，然后在meta标签中加上计算出的缩放比例，这样是不是也能解决问题呢？网易的metahandler.js就是这样实现的，只要在页面中引入js，并在js中结尾设置好需要的宽度12// 调用自适应屏幕的功能函数，位于182行opt.fixViewportWidth(640); 在页面加载的时候，js就能根据当前的手机智能的计算出缩放比例并加上这是一个不错的想法，但是在使用的过程中有几个小缺陷： 指定宽度需要在js中修改，应该封装出接口供使用者使用，使用者需要自己修改封装一下 js没有监听屏幕变化的事件，在手机横屏的时候不能满屏 总结手机适配的方案有很多，大家可以选择合适自己的，有一些方案，如响应式也是不错的，关键需要看页面的布局和功能复杂度，大家理解了手机适配的原理，在以后可以更好的更快的构建适合自己的移动端网页。另外我集合了一点方案在我的git上，欢迎大家star和关注https://github.com/zk-/mobile-response]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react分享与入门]]></title>
    <url>%2F2017%2F03%2F24%2Freact-share%2F</url>
    <content type="text"><![CDATA[视频投稿在了b站，一共分了3p，有错误和遗漏欢迎大家弹幕指出]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用js来做图像处理（二）]]></title>
    <url>%2F2017%2F02%2F22%2Fimages-2-canvas2%2F</url>
    <content type="text"><![CDATA[高斯模糊是根据一个像素周围的像素的值通过复杂的计算获得一个与周围像素近似值的技术，如果只是简单的判断，那就是马赛克了。资料参考：阮老师的高斯模糊的算法 基础知识读过阮老师的文章我们知道以下几点 所谓”模糊”，可以理解成每一个像素都取周边像素的平均值。 “中间点”取”周围点”的平均值，就会失去细节。 取值范围越大，”模糊效果”越强烈。 正态分布显然是一种可取的权重分配模式。 利用状态发布的权重值可以算出中心点合适的加权平均值。 图像都是二维的，所以我们需要二维正态分布。 如果一个点处于边界，周边没有足够的点，就把已有的点拷贝到另一面的对应位置，模拟出完整的矩阵。 矩阵函数如下： 实现有了理论和函数支持，做起来就比较容易了我们先尝试做一个模糊半径为1像素的图。在半径为1像素的情况下，中心点需要知道周围8个点的权重值，利用前面的函数，写出下面的代码123456789101112131415161718var lisanzhi = 0.9; //离散值var r = 1; //设半径为1像素var zhijing = 2*r + 1; //直径var pointNums = zhijing*zhijing; //需要计算点的数量var middleValue = Math.ceil(pointNums/2); //中值var temp = 1/(2 * Math.PI * lisanzhi * lisanzhi); //公式中一样的下半部分var gaosiData = []; //存储结果for (var i = 0; i &lt; pointNums; i++) &#123; var x = Math.abs(i%zhijing - r); //获取对应值的x、y值 var y = Math.abs(r - parseInt(i/zhijing)); gaosiData[i] = Math.pow(Math.E , 0 - (x*x + y*y)/(2 * lisanzhi * lisanzhi)) * temp; //套用公式计算&#125;var sum = gaosiData.reduce(function(a,b) &#123; //求和 return a + b; &#125;)gaosiData = gaosiData.map(function(item) &#123; //求权重 return item/sum;&#125;) 结果如下接下来就是求中心点周围的点在数组数据中的下标值，实现如下12345678910111213var roundArray = [], //用来存放结果maxIndex = canvas.width * canvas.height * 4; //数组数据中最大下标for (var k = 0; k &lt; pointNums; k++) &#123; //根据下标和中心点的下标距离，求出真正下标 var juli = k - middleValue + 1, beishu = parseInt(juli/zhijing), yushu = juli%zhijing; roundArray[k] = i + 4*(beishu*canvas.width+yushu);&#125;for (var j = 0; j &lt; roundArray.length; j++) &#123; //因为部分点在边缘，所以一些下标超过正常范围的就取对应点的下标 if (roundArray[j] &lt; 0 || roundArray[j] &gt; maxIndex) &#123; roundArray[j] = roundArray[pointNums - 1 - j]; &#125;&#125; 做完这些，我们就可以根据前面两步的结果，计算最终中心点的值了12345678910var temp=0,temp1=0,temp2=0;for (var m = 0; m &lt; pointNums; m++) &#123; //求和 temp += imageDatas.data[roundArray[m]] * gaosiData[m]; temp1 += imageDatas.data[roundArray[m]+1] * gaosiData[m]; temp2 += imageDatas.data[roundArray[m]+2] * gaosiData[m];&#125;imageDatas.data[i] = temp;imageDatas.data[i+1] = temp1;imageDatas.data[i+2] = temp2;imageDatas.data[i+3] = 255; 效果图如下 结论这一篇是在前面的文章基础上一步步推导过来的，高斯模糊本身不难，只要掌握原理即可很容易做到，本篇所写代码没有做性能优化，读者可以进一步开发，优化性能，功能解耦。实验平台：点这里]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>高斯模糊</tag>
        <tag>灰度处理</tag>
        <tag>反色</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用js来做图像处理（一）]]></title>
    <url>%2F2017%2F02%2F21%2Fimages-2-canvas%2F</url>
    <content type="text"><![CDATA[所有能被js实现的东西，最终都会以js的方式被实现 概述正如上面所说，昨天开始打算尝试能不能用js做一些图像处理的工作，直到现在，本人已经用js下的canvas实现了图像的灰度处理，反色，以及高斯模糊等功能。资料参考：阮老师的高斯模糊的算法 基础知识导入图像canvas导入图像非常简单，使用canvas自带的drawImage函数即可导入123456var image = new Image;image.src = './images/mm1.jpg'image.onload = function ()&#123; //在图像加载完成的时候导入 ctx.drawImage(image,0,0) //后面的两个参数是导入图片的坐标&#125; 效果如下，左图为原图，右图为canvas导入的图 获取图像数据canvas在这里也为我们提供了简便的函数getImageData，用这个函数可以获取目标区域里图像的数组数据。12345canvas.width = width;canvas.height = height;ctx.drawImage(image,0,0);var imageDatas = ctx.getImageData(0,0,width,height); //参数意思是坐标已经x、y轴的偏移量console.log(imageDatas) 获取数据如图 重绘图像上面我们拿到了图像数据，这时候假如我们处理好了，怎么用新数据重绘呢？可以直接用canvas自带的putImageData函数1ctx.putImageData(imageDatas,0,0) 关于图像数据我们知道图像的每一个像素的颜色都有rgb三个颜色构成，canvas还增加了一种，就是透明度，所以在canvas中每一个像素都是有rgba值的。对应到数组数据中，每四个数组元素表示一个像素的rgba值。由此我们可以做个小练习，图像的第二排第一个像素的位置是 0 + 4 x (图像宽度 + 1)。基础只是已经了解的差不多了，现在开始简单的尝试 灰度处理把图像做灰度处理很简单，只要把每个像素的rgb三值做成一样的就可以了，因为每个像素的rgb的值不同，所以我们可以取平均值。代码如下1234567for (var i = 0; i &lt; imageDatas.data.length; i+=4) &#123; //每四个元素代表一个像素 var ddd = (imageDatas.data[i]+imageDatas.data[i+1]+imageDatas.data[i+2])/3; imageDatas.data[i]=ddd; imageDatas.data[i+1]=ddd; imageDatas.data[i+2]=ddd; imageDatas.data[i+3]=255; //透明度就最高即可&#125; 效果如下 反色反色的方法是取对应rgb中相反的值，即用255减去对应的值，结果为所求的值。123456for (var i = 0; i &lt; imageDatas.data.length; i+=4) &#123; //每四个元素代表一个像素 imageDatas.data[i]=255-imageDatas.data[i]; imageDatas.data[i+1]=255-imageDatas.data[i+1]; imageDatas.data[i+2]=255-imageDatas.data[i+2]; imageDatas.data[i+3]=255; //透明度就最高即可&#125; 效果如下 结语第一篇主要是介绍canvas下处理图像数据需要的一些基本知识，以及灰度处理和反色两个简单的图像处理技术，下一章会重点介绍如何对图像进行高斯模糊，以及高斯模糊的算法。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>高斯模糊</tag>
        <tag>灰度处理</tag>
        <tag>反色</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用脚本锁住百度云下载加速倒计时,从而实现无限加速]]></title>
    <url>%2F2017%2F01%2F06%2F%E7%94%A8%E8%84%9A%E6%9C%AC%E9%94%81%E4%BD%8F%E7%99%BE%E5%BA%A6%E4%BA%91%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E5%80%92%E8%AE%A1%E6%97%B6-%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[百度云本来是会员可以加速，后来要超级会员才能加速，有点烦，最近手头又有一个大文件要下载，限速真心不爽，所以做了个小工具，现在简单说说原理。 作用如题，锁住百度云下载倒计时，实现无限时间加速 下载地址点击这里下载 用法 运行百度云 打开小程序 下载文件，出现免费加速时，点击免费加速，然后按F2，即可锁住时间 平台在我的win10 32位小本子上测试正常，其他平台没有机子做测试，有问题的同学可以评论告诉我百度云版本为当前时间最新版本5.5.2，是否兼容老版本以及未来的新版本主要看百度云改不改逻辑了 原理原理很简单，百度云没有在服务器端对免费云加速时间做校验，所以本地修改逻辑就可以了 思路有两种方法可以实现一种是找到控制时间变量的基址以及算出偏移量，把数值改大即可，但是考虑到如果百度云更新版本的话基址可能就会变掉，这样就失效了，所以不采用还有一种是找到对时间变量做写操作的地址，注入脚本改写操作，让时间不减少就可以了，考虑到百度云近期不会对这一块有改动，如果做成工具，可以兼容多个版本在小工具的使用体验上一种是我直接把改好的小程序导出出来，做成一个修改版的百度云还有一种是写成一个小工具，在用户需要时候使用因为第一个是破坏式的方法，而第二个给了用户的选择权，使用完重启百度云，就会恢复正常，不影响其他使用，还可以兼容部分版本百度云，所以综合考虑用了第二个方案]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>百度云</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impress简易教程]]></title>
    <url>%2F2016%2F12%2F23%2Fimpress%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[快过年了，作为一个前端工程师，要写年终总结ppt啥的了，这里介绍一个炫酷的js框架，用网页实现比ppt还炫酷的效果。 效果展示聚众编码！ 原理介绍这里用的impress.js框架，这个框架帮你做到的是，把指定的div标签变成一个个独占整个页面的元素，通过给出的接口进行定位，是三维上的定位！然后通过js控制把每个元素转到当前窗口来，在浏览器支持css3的情况下使用css3的动画功能来实现的。 项目地址和文档地址项目地址文档地址 起步首先要引入impress.js文件，和普通的js引入方式是一样的然后在文档里加入代码1&lt;div id="impress"&gt;&lt;/div&gt; //id可以自定义 然后在引入的impress文件下插入这段代码12impress( "root" ); //这里是你的id，如果id是impress，则这一步省略impress().init(); 插入ppt基础在你指定的根div中间插入ppt类的div12345&lt;div id="impress"&gt; &lt;div id="test" class="step" data-x="0" data-y="0"&gt; test &lt;/div&gt;&lt;/div&gt; 这里div的class必须要有’step’，id可以有可以没有，如果没有，impress就会把你的id默认变成’step-1’这样的。‘data-x’和’data-y’这样的就是ppt的定位 2D平移如果我们再加入一段ppt类的div，页面就可以平移动起来了12345678&lt;div id="impress"&gt; &lt;div id="test1" class="step" data-x="0" data-y="0"&gt; test1 &lt;/div&gt; &lt;div id="test2" class="step" data-x="1600" data-y="0"&gt; test2 &lt;/div&gt;&lt;/div&gt; 缩放我们想加入缩放的话只要加入’data-scale’这个属性就可以了，赋值为数字，越大缩放越大123&lt;div id="test" class="step" data-x="1600" data-y="0" data-scale="3"&gt; test&lt;/div&gt; 2D旋转如果想做旋转效果的ppt，加入’data-rotate’属性，赋值范围0~360123&lt;div id="test" class="step" data-x="1600" data-y="0" data-rotate="90" data-scale="3"&gt; test&lt;/div&gt; 3D定位加入’data-z’属性实现3D空间上的定位 3D翻滚可能最炫酷的效果就是这个了，需要配合3D定位，属性有两个’data-rotate-x’和’data-rotate-y’，分别实现横向和纵向翻滚。123&lt;div id="test" class="step" data-x="6200" data-y="4300" data-z="-100" data-rotate-x="-40" data-rotate-y="10"&gt; test&lt;/div&gt; 方法接口impress还给出了方法接口 .init()初始化用途12var api = impress();api.init(); .next()切换下一个ppt的功能123var api = impress();api.init();api.next(); //使用方法下面都一样 .prev()切换前一个ppt的功能 .goto( stepIndex | stepElementId | stepElement, [ duration ] )切换到指定ppt的功能，接受id和数字和dom元素，还能配置切换时间 事件监听接口impress给出了两个事件监听接口impress:stepenter 切入当前ppt的事件impress:stepleave 切出当前ppt的事件12345678910var rootElement = document.getElementById( "impress" );rootElement.addEventListener( "impress:stepenter", function() &#123; var currentStep = document.querySelector( ".present" ); console.log( "Entered the Step Element '" + currentStep.id + "'" );&#125;);rootElement.addEventListener( "impress:stepleave", function(event) &#123; var currentStep = event.target console.log( "Left the Step Element '" + currentStep.id + "'" );&#125;); 样式impress还给出了一些样式特效，具体的读者自己去文档看吧！我就偷懒啦！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>impress</tag>
        <tag>js框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github以及github page访问缓慢的解决办法]]></title>
    <url>%2F2016%2F11%2F30%2Fgithub%E4%BB%A5%E5%8F%8Agithub-page%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[如题，解决办法如下修改hosts，加入这两行，其中zk-.github.io可以换成你的博客地址12151.101.100.133 zk-.github.io192.30.253.113 github.com]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性初探]]></title>
    <url>%2F2016%2F11%2F30%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[最近学的东西有点多，主要是最近从追求深度的一个坑里爬了出来，因为一无所获==！这样下去就是浪费时间，所以把一些计划上学的东西学一遍，开始技能树乱加点模式。。这次ES6新增了几个新特性，解决了平常使用js时需要处理一些麻烦的东西时的不便，增加了声明函数时使用箭头函数这种更清晰的语法模式（我是没觉得哪里好了，感觉更乱了==），还增加了一些牛逼的自定义迭代器这样的功能（嗯，越来越像python了），现在我就列举说明一下其中几个新特性及其用法。 开始前的准备因为es6的语法每个浏览器支持的程度不一样，所以我们使用一种安全的方法来调试我们的脚本首先安装es6转码器babel提供的命令行工具1npm install --global babel-cli 因为这款工具对于es6的语法支持的不是很全，我们需要安装官方提供的转码规则集1npm install --save-dev babel-preset-es2015 然后在我们的项目下新建一个.babelrc文件并写入123456&#123; "presets": [ "es2015" ], "plugins": [] &#125; 这一步是为了让babel在执行的时候采用上面安装的规则集。这些都搞完我们就可以开始学习了，在学习测试的时候可以用三种命令行方式验证我们的脚本一个是 babel yourprogarm.js这个可以直接在命令行输出翻译出来的脚本一个是 babel-node yourprogarm.js (用node直接输出也可以)这个可以直接运行你的脚本，输出结果一个是 babel yourprogarm.js -o compiled.js将你的脚本转成es5语法并保存到指定文件里面大家各取所需 块作用声明let以及常量声明const废话不多说，直接先看代码1234if (true) &#123; var a = 4&#125;console.log(a) //4 我们都知道在这个例子里面，a虽然在if中声明了，但是if没有块级作用域，所以在外部也能正常访问a，这给初学者或多或少带来了理解困难，因为这是js语言的缺陷。在es6中，我们有了let这个块级声明，再也不用担心这类问题了1234if (true) &#123; let a = 4&#125;console.log(a) //undefined 另外我们在自己的程序中有时候希望声明一些常量，又不希望被别人更改，这时候就可以使用es6提供的const来声明变量12const a = 4;a = 5; //error 这些用法都非常简单易懂，但是要注意的是babel对这些特性的兼容是怎样实现的在对于支持这些语法特性的浏览器来说，这些语法非常的安全，但是如果对于不支持这些语法特性的浏览器，babel需要翻译成浏览器支持的语法才能正常表现，现在我们就用babel命令来输出翻译后的代码是什么样的拿第二段的代码举例，翻译后是这样的翻译的结果是babel在对应的变量前加了下划线，所以我们要注意的一点是在使用babel和es6的时候，不要出现相似变量名之间只差一个下划线的情况，这样就会出现难以调试和发现的bug 解构英文名DESTRUCTURE（扔到有道翻译里面意思是“变性” ==！）实际意思是一种新的赋值模式，叫解构解构赋值提供了一种位赋值12var [a, b] = [1, 2]console.log(a, b) //输出结果1 2 大家看到了，就是对应位置的复制，这样以后如果需要交换变量值的时候就很方便，只需要一行代码就能实现1[a, b] = [b, a] 解构赋值还提供了一种提取属性的赋值方法123var pt = &#123;x: 123, y: 444&#125;;var &#123;x, y&#125; = pt;console.log(x, y); // 123 444 结果很明白，有的同学可能有疑问，如果我不想用xy这样和对象名属性一样的变量名怎么办，简单，在后面加上冒号就可以了12345var pt = &#123;x: 123, y: 444&#125;;var &#123;x:myvalue, y&#125; = pt;console.log(y); // 444console.log(x); // undefinedconsole.log(myvalue); // 123 字面量属性可计算这个特性很好理解，平常我们在一个对象中，读取或者写入一个动态生成的属性时，是这样做的1234var b = 'example';var a = &#123;&#125;;a[b + 'A'] = 4console.log(a['exampleA']) //4 在表达式中计算，现在es6加入的特性就是，在对象声明字面量的时候，就可以使用计算属性1234var a = &#123; ['example' + 'A']:6&#125;console.log(a.exampleA) //6 箭头函数 =&gt;说实话这个玩意我开始用的时候真不习惯，感觉上可读性也没有多少提高，但是推出这个语法一定有他的用意，先说用法一般函数声明是这样的123function abc()&#123; // your code here&#125; 而es6的语法是这样的123var abc = () =&gt; &#123; //your code here&#125; 这个()就是声明参数的地方，剩下的就是函数解构体，其实箭头函数就是声明了一个匿名函数并复制给了abc，所以匿名函数的写法就是这样1setTimeout(()=&gt;&#123;console.log('123')&#125;,1000) 就是样子变了一下，如果说有什么要值得注意的话，就是箭头函数创建实名函数的时候，它是一个表达式，所以没有函数声明提前的说法。1234console.log(a) //undefinedvar a = () =&gt; &#123; // your code here&#125; REST AND SPREAD(延展运算符)上面说过es6把一些常见的其它语言的特性拿到了es6中来，这就是其中的一个在函数中，我们的参数可以通过arguments来引用进来，如果一个函数要求的参数是2个，如果调用的时候传入了1个是不会报错的，只不过第二个参数默认会赋值undefined，如果传入了3个参数，也不会报错，多出来的那一个可以通过arguments[2]访问到。可能是es6的专家们希望js能表现的和正常的语言一样吧，在es6中，参数可以这样写1234var abc = (...args) =&gt; &#123; console.log(args)&#125;abc(1, 2, 3, 4) //1 2 3 4 前面的三个点表示任意多的参数，我们还可以给参数赋默认值12345var abc = (a = 6) =&gt; &#123; console.log(a)&#125;abc() //6abc(4) //4 利用这些特性我们可以很方便的取到多余的参数123456var abc = (a, b, ...args) =&gt; &#123; console.log(a + b) console.log(args)&#125;abc(1, 2) //3 []abc(1, 2, 3, 4) //3 [3, 4] 模版说模版实际上es6给定义的模版功能比较弱，模版文本用 ` 围起来，这个标点就是键盘左上方esc键下面的那个键，动态的文本内容用 ${} 表示，所以基本用法如下所示123var name = 'zk';var templateString = `my name is $&#123;name&#125;, and I know 1 + 1 = $&#123;1 + 1&#125;`console.log(templateString) //my name is zk, and I know 1 + 1 = 2 在${}中我们可以放入变量也可以放入表达式，但是 templateString 在定义的时候就已经被计算出字符串并赋值给了它，所以templateString这样的变量在生成的时候就只能是固定的字符串格式。 class类ladys and 乡亲们，你们盼望已久的面向对象终于来啦！ladys and 乡亲们，你们盼望已久的面向对象终于来啦！ladys and 乡亲们，你们盼望已久的面向对象终于来啦！js面向对象编程说了辣么多年，网上的相关文章也是辣么多，现在终于出来了，刚刚看到的时候说实话我是很激动的，但是研究了一下，发现因为js的历史原因，实际上，es6对于面向对象的特性实现只是我们在写代码的时候感觉像是那么回事，实际上还是构造器以及原型链，继承方式也是这两种不管了，最起码写写代码的体验上提升了很多。 有对js对象继承不太理解的同学，可以看看这篇我的文章js继承的方式和意义 上代码1234567891011class Parent&#123; constructor(name)&#123; //这是构造器 this.name = name; &#125; sayHello()&#123; //这是原型方法 console.log('my name is ' + this.name) &#125;&#125;var parent = new Parent('parent')console.log(parent.name) //parentparent.sayHello() //my name is parent 继承的写法也很容易，用关键词extends，父类用super表示123456789101112131415161718192021222324252627class Parent&#123; constructor(name)&#123; //这是构造器 this.name = name; &#125; sayHello()&#123; //这是原型方法 return 'my name is ' + this.name &#125;&#125;class Child extends Parent&#123; constructor(name, sex)&#123; super(name); //构造器继承 this.sex = sex; &#125; sayHello()&#123; console.log('i am a child,' + super.sayHello()) //原型链继承 &#125; saySex()&#123; console.log(this.sex) &#125;&#125;var child = new Child('baby','male')console.log(child.name) //babyconsole.log(child.sex) //malechild.sayHello() //i am a child,my name is babychild.saySex() //male 模块module模块加载在es6中得到了原生支持123456// Message.jsexport const message = 'Hello Babel';// other.jsimport &#123;message&#125; from './Message';console.log(message); // Hello Babel 导出可以实名导出也可以默认导出12345678910111213141516171819202122// Message.jsconst greeting = 'Hello';const name = 'Babel';const version = 'v5.0';export const obj = &#123; greeting: greeting, name: name, version: version&#125;;// Message.jsconst greeting = 'Hello';const name = 'Babel';const version = 'v5.0';export default &#123; greeting: greeting, name: name, version: version&#125;;// other.jsimport &#123;greeting, name, version&#125; from './Message'; 迭代器这是一个大内容，下一篇开始说这个概念吧。。。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解微信小程序]]></title>
    <url>%2F2016%2F11%2F22%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一个月前微信小程序火爆朋友圈，当时我对这个并不是很感兴趣，现在公司需要开发这个，花了一天的时间，把微信的文档看了个大概，看到了很多技术和工具的影子，其实微信小程序不是什么新鲜的东西，都是我们平常学习过的东西。 概述微信小程序可以通过微信获取到两个方面信息和权限，一个是手机使用者的手机信息和权限，一个是获取其微信用户的信息。而第一个是安装微信时获取到的权限，小程序就是通过调用微信的接口获取手机信息和权限，而第二个则是微信自带的功能。所以小程序对于微信来说，就像插件对于chrome浏览器一样，从配置上，这二者也有异曲同工之处。小程序与插件相比，其创新程度在于两点：小程序的页面核心是一个响应的数据绑定系统，视图层WXML文件是一种类似xml语法的文件，主要承载页面的渲染显示，逻辑层js文件为视图层主要提供数据和行为。小程序的第二个创新之处在于为小程序以及其页面提供了生命周期函数，当用户加载小程序，退出小程序，加载页面销毁页面时都会有对应的生命周期函数可以贡开发者使用。下面就开始说一说小程序的基本内容 文档地址微信小程序的文档写得非常的完美，主要从结构、页面组件、权限接口三个方面诠释了小程序的主要内容，其文档地址大家可以点击这里访问。 目录结构首先看一眼一个基础小程序的目录结构12345678910111213141516171819E:\TEST│ app.js //入口函数，程序生命周期函数声明的地方│ app.json //全局配置，程序声明获取权限的地方│ app.wxss //全局样式，程序定义公共样式的地方│├─pages│ ├─index│ │ index.js│ │ index.wxml│ │ index.wxss│ ││ └─logs│ logs.js //逻辑层代码，包含小程序数据和行为│ logs.json //小程序声明获取权限的地方，只能获取部分权限(window)，向上覆盖全局配置│ logs.wxml //视图层，小程序页面承载内容的地方│ logs.wxss //小程序页面样式，向上覆盖│└─utils util.js //自定义公共函数，文件夹和文件的名字随意 一个小程序的整个目录结构差不多就是这样，根目录下的app.js为小程序的入口函数，页面的声明通过app.json来实现，小程序要获取用户的各种信息和权限需要通过这里声明，同时小页面包含的所有页面也需要在这里声明。小程序目录结构的第二个重点是页面下的文件，一般页面下需要包含.js .json .wxml .wxss这四类文件，文件名与文件夹名同名，相关功能已经在注释中说明，不在赘述。可以看到小程序的文件结构非常的简单，我们学习它也很容易 权限获取权限获取分两个方面，一个是根目录下app.json的权限获取123456属性 类型 必填 描述pages String Array 是 设置页面路径window Object 否 设置默认页面的窗口表现tabBar Object 否 设置底部 tab 的表现networkTimeout Object 否 设置网络超时时间debug Boolean 否 设置是否开启 debug 模式 其中window是定义小程序页面的默认设置，如果页面中没有json配置文件或者json配置文件声明的没有覆盖声明对应的权限，则使用默认app.json下的配置，页面下的json文件只能覆盖window属性的权限。 视图层组件小程序的页面wxml文件使用的是一个类似xml语法的文件，每一个标签都有其对应的闭合标签(templete标签和import标签和include标签除外)，全部都是小写。例如&lt;image&gt;必须有对应的&lt;/image&gt;，而且大小写敏感，写成&lt;/Image&gt;是不可以的。页面标签我总结了一下从功能上可以分为三类第一类是普通的视图容器view和block，这两类都是识图容器一类，在页面中主要作用是分割页面内容，并且和其他标签一样，可以承载数据和渲染逻辑。12345678910// pages/test/test.wxml&lt;view&gt;&#123;&#123;testData&#125;&#125;&lt;/view&gt; //直接使用在js的data下声明的数据// pages/test/test.jsPage(&#123; data:&#123; testData:&apos;hello world!&apos; &#125;, ···省略&#125;) 效果图承载行为注意通过bindtap或者catchtap来实现，这两种区别稍后在说明，现在用bindtap举例1234567891011121314151617// pages/test/test.wxml&lt;view bindtap=&quot;testtap&quot;&gt;&#123;&#123;testData&#125;&#125;&lt;/view&gt; //绑定testtap函数// pages/test/test.jsPage(&#123; data:&#123; testData:&apos;hello world!&apos; &#125;, testtap:function(event)&#123; //点击时执行的函数 wx.showToast(&#123; title: &apos;hello world&apos;, icon: &apos;success&apos;, duration: 2000 &#125;) &#125;, ···&#125;) 效果图 第二类则是小程序内置的标签，这些标签功能多而且强大，下面就拿标签picker举例1234567891011121314151617// pages/test/test.wxml&lt;picker bindchange=&quot;bindPickerChange&quot; value=&quot;1&quot; range=&quot;&#123;&#123;pickerData&#125;&#125;&quot;&gt; &lt;view class=&quot;picker&quot;&gt; 选择 &lt;/view&gt;&lt;/picker&gt;// pages/test/test.jsPage(&#123; data:&#123; testData:&apos;hello world!&apos;, pickerData:[1,2,3] &#125;, bindPickerChange: function(event)&#123; console.log(&apos;test&apos;) &#125;···&#125;) 效果图 第三类则是模版标签，即templete标签，为了便于管理，我们需要在根目录下新建一个templete文件夹，在文件夹内新建我们的模版文件，文件名自定义。1234// templete/test.wxml&lt;template name=&quot;test&quot;&gt; &lt;text&gt;&#123;&#123;number&#125;&#125;&lt;/text&gt;&lt;/template&gt; 我们需要为标签添加一个name属性(在所有的模版文件中，name属性最好不一样)，里面写好我们所需要的内容，在需要使用模版的文件中使用import来引入，文件中通过is属性来使用，data属性来填入数据12345// pages/test/test.wxml&lt;import src=&quot;../templete/test.wxml&quot;/&gt;&lt;template is=&quot;test&quot; data=&quot;&#123;&#123;number: &apos;1&apos;&#125;&#125;&quot;/&gt;&lt;template is=&quot;test&quot; data=&quot;&#123;&#123;number: &apos;2&apos;&#125;&#125;&quot;/&gt;&lt;template is=&quot;test&quot; data=&quot;&#123;&#123;number: &apos;3&apos;&#125;&#125;&quot;/&gt; 效果图是不是感觉似曾相识？没错，开发过vue的同学有福了，其实小程序页面的开发逻辑和vue有很多相似的地方 逻辑层逻辑层开发需要先注册，注册有程序注册，即在app.js里面用App()方法，还有页面注册，即在页面文件js中用Page()方法。每个页面都有独立的作用域，小程序提供getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈，getCurrentPages只能在页面中使用，getApp哪里都能用，主要用来设置和读取全局变量 注册程序程序通过app.js来注册，提供三个周期函数，onLunch当初始化完成启动小程序的时候，onShow当小程序从后台进入页面的时候，onHide从前台进入后台的时候。开发者可以在App()中定义其他的属性和方法，作为全局作用域。123456789101112App(&#123; onLaunch: function() &#123; // Do something initial when launch. &#125;, onShow: function() &#123; // Do something when show. &#125;, onHide: function() &#123; // Do something when hide. &#125;, globalData: &apos;I am global data&apos;&#125;) 注册页面页面通过在app.json下指定的文件名的js文件来注册，提供一个默认属性和七个周期函数，默认属性data，为页面提供初始化数据，wxml渲染页面时提供数据。onLoad为生命周期函数，页面加载是触发onReady为生命周期函数，页面初次渲染完成时触发onShow为生命周期函数，监听页面显示时触发onHide为生命周期函数，监听页面隐藏时触发onUnload为生命周期函数，监听页面卸载(关闭这个页面或者重定向页面时候触发)onPullDownRefresh为页面相关事件处理函数，用户下拉动作时触发onReachBottom为页面相关事件处理函数，页面上拉触底时触发补一张官方给出的页面生命周期图 样式样式在前面有提及过，这里要特别指出的是，小程序的样式文件wxss具有大部分css的特性，在尺寸单位上小程序扩展了两个单位一个是rpx，可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素一个是rem，规定屏幕宽度为20rem；1rem = (750/20)rpx 。在样式导入上，支持css的内联样式，样式文件与识图文件名相同默认导入进去，在样式文件中可以使用@import “common.wxss”导入其他文件，app.wcss默认给所有页面导入进去。 其他在小程序中，因为是在JsCore中运行，所以不存在window或者globle这样的对象，所以很多js库不能直接引入进去，只要里面使用了window这样的对象。 总结小程序的开发思路和chrome插件的开发思路有很多相似之处，页面的构建和vue很相似，目前来说小程序没有引入更多复杂的概念，文章剩下没有讲过的东西大多数都是一些api函数，需要时查一下调用一下即可，总体感觉文章说的有一点混乱，读者有意见可以在下面提出，我会及时修正，以后我也会优化这篇文章，在不久我还会出第二篇小程序的实践文章，点击文章下面的微信小程序标签就可以看到所有有关微信小程序的文章，或者订阅rss也可以。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js继承的方式和意义]]></title>
    <url>%2F2016%2F10%2F26%2Fjs%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[在写这篇博客的时候，我就做好了撕逼的准备js是一个无类语言，在日常编码中，我们可能需要js来创建一些类似面向对象里面“类”的东西，来实现代码复用。js是一个基于对象的语言，没有类的概念，但是我们可以通过一些办法来模拟实现类的功能。在写这篇博客的时候，我先在百度上搜了一下，网上说js的继承有五种办法 1.使用对象冒充实现继承2.采用call方法改变函数上下文实现继承3.采用Apply方法改变函数上下文实现继承4.采用原型链的方式实现继承5.采用混合模式实现继承 具体的文章大家可以自己百度一下，这样的文章网上很多，而且长得都一样。但是我对此有一点不同的看法，js模拟实现类功能从实现的意义上来说最多只有3种，即1.原型链继承2.构造器继承3.原型链和构造器混用继承 让我们一点点深入，来慢慢了解，为什么我说只有三种方法 原型链继承原型链的概念其实不难理解，就是一种类似于职责链一样模式的模式，什么是职责链呢？举个例子，我们去银行取钱，如果我们只是取几百块前，最快最好的办法是直接去ATM机取钱如果我们要取几十万，就必须要去柜台，让银行的工作人员帮你取钱如果我们要是取几个亿 ==！ 银行人员一定非常的紧张，告诉你过几天再来，柜台上没有那么多钱，然后再把事情报告给当地行长，等到前到位的时候通知取钱咳咳，如果我们想和银行谈一个价值几百个亿的合作♂ 这件事都不是ATM机、银行工作人员、当地行长能接手的事，他们就需要把这件事上报到总部，让总部的人过来和我们来谈合作的事在这个实例中，我们能看到的就是职责链模式，就是消费者产生一个需求的时候，生产者接手这个需求，如果不能处理它，就往上传递，直到有一个生产者能够处理它 原型链就是一样的结构，js内置了许多对象，所有的对象，除了字符串、数字、布尔值、null和undefined以外，他们的原型链的终点都是Object 这句话不是很准确，字符串、数字和布尔值是一种不可变的对象，但是最终点也是ObjectObject的原型链是null 原型链呢就是一个对象，你调用他的方法，比如对象A，你调用A.sayName()，如果A有sayName这个方法，则直接调用，如果没有，则通过A是原型链向上查找，如果原型链上有这个方法，则调用，没有就继续查找，如果找不到，则会返回一个Uncaught TypeError错误或者undefined。如果对象和原型链上都有这个方法，则现有的方法会覆盖原型链上的方法。举个例子123456789function Parent() &#123;&#125;Parent.prototype.sayHello = function() &#123; console.log('hello parent')&#125;function Child() &#123;&#125;Child.prototype = new Parent;var child = new Child;child.sayHello() //输出hello parent 我们看到child调用sayHello成功了，调用的是Parent的方法，我们再看一下覆盖的情况12345678910111213function Parent() &#123;&#125;Parent.prototype.sayHello = function() &#123; console.log('hello parent')&#125;function Child() &#123;&#125;Child.prototype = new Parent;Child.prototype.sayHello = function() &#123; console.log('hello child')&#125;;var child = new Child;child.sayHello() //输出hello childchild.constructor.prototype.sayHello() //输出hello parent 我们可以看到child的sayHello覆盖了parent的方法，但是我们可以通过访问constructor看到实际上这个方法还存在的。 构造器继承js函数可以被当作构造器使用，通过返回的对象完成构造如果没有指定返回一个对象，默认返回的是this举个例子12345678910111213function Parent() &#123; this.name = 'parent'&#125;var parent = new Parentconsole.log(parent.name) //输出parentfunction AnotherParent() &#123; this.name = 'parent' var obj = &#123;name:'hahaha'&#125;; return obj;&#125;var anotherparent = new AnotherParent;console.log(anotherparent.name) //输出hahaha 而所谓构造器继承，就是把需要继承的对象在构造过程中，调用被继承的对象的构造方法来处理这个继承对象需要构造的目标让我们来实现一个构造器继承1234567891011function Parent() &#123; this.name = 'parent'&#125;function Child() &#123; var parent = Parent.bind(this); //将执行环境绑定到Child来 parent(); this.age = 10;&#125;var child = new Child;console.log(child.name) //输出parentconsole.log(child.age) //输出10 是不是很简单？其实这一段的代码和下面这段代码是一样的1234567function Child() &#123; this.name = 'parent'; this.age = 10;&#125;var child = new Child;console.log(child.name)console.log(child.age) 这就是构造器继承，实际上这个方法和上面提到的网上的方法的123方法是同一种，换汤不换药，原理都是通过构造器实现继承可以看看网上给的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//1.使用对象冒充实现继承function Parent(firstname) &#123; this.fname=firstname; this.age=40; this.sayAge=function() &#123; console.log(this.age); &#125; &#125; function Child(firstname) &#123; this.parent=Parent; this.parent(firstname); //实际上这一段的意义就是将执行环境上下文改变了,和上面的例子一样 delete this.parent; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125; &#125; var mychild=new Child("李"); mychild.saySomeThing(); // 2.采用call方法改变函数上下文实现继承function Parent(firstname) &#123; this.fname=firstname; this.age=40; this.sayAge=function() &#123; console.log(this.age); &#125; &#125; function Child(firstname) &#123; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125; this.getName=function() &#123; return firstname; &#125; &#125; var child=new Child("张"); Parent.call(child,child.getName()); // call只是借用罢了,作用的对象还是child,原理还是构造器继承child.saySomeThing(); // 3.采用Apply方法改变函数上下文实现继承 function Parent(firstname) &#123; this.fname=firstname; this.age=40; this.sayAge=function() &#123; console.log(this.age); &#125; &#125; function Child(firstname) &#123; this.saySomeThing=function() &#123; console.log(this.fname); this.sayAge(); &#125; this.getName=function() &#123; return firstname; &#125; &#125; var child=new Child("张"); Parent.apply(child,[child.getName()]); //???换个函数就能算一种了???child.saySomeThing(); 我们可以看到网上说的这三种其实是一种，都是构造器继承，只是表现的手法不一样，不能算三种（如果有读者对我的观点有什么不同的意见，欢迎在下面评论提出来） 关于混合继承的吐槽如果按照我刚才的逻辑，混合继承应该也不算一种继承方式，这点我承认，但是我还是把它拿出来了算作一种，原因很简单，就是因为它的使用场景和其他两种都不一样，而上面那三种的基本就是一样的，至于都有哪些不一样，请往下看。 意义以及优缺点先说结论，原型链继承中的原型对象是共享的，构造器构造出来的对象是独立的 原型链继承的意义以及优缺点我们来看这样的一段代码12345678910111213function Parent() &#123;&#125;Parent.prototype = &#123; testArray:[1,2,3]&#125;;function Child() &#123;&#125;Child.prototype = new Parent;var child1 = new Child;var child2 = new Child;child1.testArray.push(4)console.log(child1.testArray) //输出[1, 2, 3, 4]console.log(child2.testArray) //输出[1, 2, 3, 4] 我们可以看到child1对象的操作影响到了child2对象，原因很简单，他们用的原型对象是相同的共享的，意思就是原型对象指向的地址是一样的，任何对Parent原型的更改，都会反应到继承他的子对象中所以在原型中是不适合写属性进去的，除非你有意把这样的功能设计进去。同时，如果判断一下结果发现child1属于Parent和Child，如果在复杂场景中，我们还需要找有没有别的对象继承了Child，这样才能确定一个对象是属于哪个构造器的，无疑非常的麻烦，这也是原型链的缺点 构造器继承的意义以及优缺点继续看一个例子12345678910111213function Parent() &#123; this.testArray = [1,2,3]&#125;function Child() &#123; var parent = Parent.bind(this)&#125;var child1 = new Child;var child2 = new Child;child1.testArray.push(4)console.log(child1.testArray) //输出[1, 2, 3]console.log(child2.testArray) //输出[1, 2, 3, 4] 和原型链不同的是，构造器的继承都是独立的互不影响查看一下类型很准确的判断出来了类型 混合继承的意义以及优缺点混合继承适用与复杂的应用场景，当需要一些对象共享一些基础的静态方法，原型链有效的减少了重复的代码，而且还能实现多态，如果子对象需要生成独立互不影响的内部对象，构造器则能够很好的维护好子对象中的内部对象而不影响其它对象原型链因为他的特殊性，还可以用原来进行共享对象的数据交换好处有很多，但是在实际生产环境中，为了便于代码的可读性以及可维护性，如果不是必须的话，最好使用一种来实现]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>继承</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记:单例模式]]></title>
    <url>%2F2016%2F10%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式是设计模式里面最简单的一种模式，但是用处非常的广泛，用好了可以小幅度的提示整个页面的性能。 定义单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。 构建思路用闭包实现创建对象并抛出引用，以后在调用时直接抛出引用，不再创建 初步实现123456789101112var createH1 = (function()&#123; var flag; //上一层的执行环境,变量没有办法被自动消除,因为下一层的函数引用的它 return function()&#123; if(flag)&#123; //判断是否有值,如果有,就返回对该值的引用 return flag &#125;else&#123; flag = document.createElement('h1'); flag.innerHTML = 'test'; document.body.appendChild(flag); &#125; &#125;&#125;)() createH1 在一开始使用了一个闭包，创建了一个只能它自己访问的值flag，然后在判断flag是否有值，如果有值，则直接返回flag的引用，如果没有则做创建操作，并给flag赋值，这样就可以保证在调用createH1这个函数时，创建操作只做了一遍，而剩下的执行都是返回引用。测试结果在js中单例模式并不是一个复杂的东西，但是能给我们日常工作带来好处，比如缓存。 实战题这是一个来自codewars的题目 Description:Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?The parameter of the function findNb (find_nb, find-nb) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + … + 1^3 = m if such a n exists or -1 if there is no such n.Examples:findNb(1071225) –&gt; 45findNb(91716553919377) –&gt; -1 大意就是给出一个很大的数字,找到他的”基数”。即给出一个数m，存在一个数n，使得m = n^3 + (n-1)^3 + … + 1^3 如果存在这个数就返回这个数,如果不存在则返回-1这道题呢用电脑实现虽然麻烦了一点，但是也不难，直接给出正常解题答案：12345678910111213141516171819202122var jisuan = function(num)&#123; var sum = 0; for(var i = num;i&gt;0;i--)&#123; sum = sum + i*i*i &#125; return sum&#125;function findNb(m) &#123; var flag=-1; var result = -1; for(var i = 1;i&gt;0;i++)&#123; if(jisuan(i)==m)&#123; result = i; break; &#125;else if(jisuan(i)&gt;m)&#123; break; &#125; &#125; // your code return result;&#125; 这样子写没什么问题，但是有一个缺点，就是如果要执行计算多个数据的话，计算机就会在每次计算都会从1开始递增计算，这无疑增加了没必要的计算时间，我们可以创建一个缓存，在不污染全局变量的情况下，把结果缓存起来，下次再执行的时候，直接查找结果并返回重新构建的代码1234567891011121314151617181920212223242526272829303132var jisuan = function(num)&#123; var sum = 0; for(var i = num;i&gt;0;i--)&#123; sum = sum + i*i*i &#125; return sum&#125;var getResult = (function()&#123; var cache = &#123;&#125;; return function(num)&#123; if(cache[num])&#123; return cache[num] &#125;else&#123; return cache[num] = jisuan(num) &#125; &#125;&#125;)()function findNb(m) &#123; var flag=-1; var result = -1; for(var i = 1;i&gt;0;i++)&#123; if(getResult(i)==m)&#123; result = i; break; &#125;else if(getResult(i)&gt;m)&#123; break; &#125; &#125; // your code return result;&#125; 让我们看看执行的效率 结语单例模式是设计模式中最简单的一个，在以后的文章里我会继续讲解更多的模式设计，写代码不一定要堆砌各种模式，但是懂一点，在生产环境中使用，就会对产品有许多好的改变。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>模式设计</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于博客内容的想法]]></title>
    <url>%2F2016%2F10%2F24%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E7%9A%84%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[说点感想从开始写博客到现在，脑子里面有无数的想法，有很多想表达的东西，但是真的到写的时候常常不知道怎么写写博客给我最大的感受就是考验表达能力，我虽然懂了，但是如果表达给你的时候你，你没懂，那责任肯定在我还有就是考研我的严谨程度，虽然不知道会有多少人来看我的博客，但是既然发布出来了，我就不能信口开河，写点东西的时候就会各种查文档，以防止被打脸还有就是对于要写的内容的焦虑，写的东西有没有过时了？写的东西是不是太早了，以后还会变的？没办法前端就是这样，更新快，分裂大 但是每一个阅读我博客的人，我觉得应该对你们负责如果你们觉得我的博客表述有问题，请在下面指正出来，我会改正如果你们觉得我说的有错误，欢迎打脸 对你们负责也是对我自己负责。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程:用自带的js原型链方法解决问题]]></title>
    <url>%2F2016%2F10%2F23%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E7%94%A8%E8%87%AA%E5%B8%A6%E7%9A%84js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[凡是存在的就是合理的，那些说函数式编程可读性差的，你就是不会啊！其实代码写久了，有时候会对一个非常长的代码文件产生厌烦感，在阅读别人的代码或者回顾自己以前写的代码时候更是如此。当你阅读到一个长长的for循环而没有注释这个for是用来干啥时，内心的戾气就更是要爆发出来。其实很多情况我们是没有必要写出这种臃肿的代码的，函数式也是可以做到。 前提本篇会深入浅出的指出日常代码可以简化的地方，包括但是不止函数式编程，在以后的文章里，我们还会进一步探讨函数式编程的各种运用。 数组在实际编码的过程中会遇到很多类数组的数据，或者一个长字符串排序等问题，以此我们可以接住数组中自带的原型方法去解决问题。 Array.prototype.every()这个方法是用来测试数组的所有元素是否都通过了指定函数的测试 every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。callback 被调用时传入三个参数：元素值，元素的索引，原数组。 举个例子 12345// 检测数组中是否全都小于100的数字var flag = [1，32，55，67，98，101，33，44，43].every(function(item， index， array)&#123; return item &lt;= 100&#125;)console.log(flag) //结果为false，101大于100 通过这个例子我们已经看到every的作用，下面看看在实际场景中的运用我们在写复选框组这个组件的时候，有一个“全选”这个复选框，当我们在手动勾选全部的子复选框时，全选框会自动勾选上，取消其中一个的时候，全选框就会取消勾选，在实际编码过程中，我们可能要写一个for循环来轮询一遍每个子组件的状态，现在我们可以用every实现 12345678910var allCheckBoxDom = document.getElementsByClassName('quanxuan')[0] //获取全选复选框var childrenCheckBoxDoms = document.getElementsByClassName('zixuanze') //获取子选择框组，这是一个类数组var flag = [].every.call(childrenCheckBoxDoms， function(item， index， array) &#123; item.checked === true&#125;)if(flag)&#123; allCheckBoxDom.checked = true;&#125;else&#123; allCheckBoxDom.checked = false;&#125; 这样就方便的实现了这个功能 对应的方法有Array.prototype.some()，其作用是只要数组中有一个满足条件，就会返回true，用法与every相同，在这里就不赘述了 Array.prototype.map()这个方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。举个例子我们通过ajax获取到的一组数据，类似这样的123456var jobs = [ &#123;name:'zk'，age:22&#125; &#123;name:'ab'，age:12&#125; &#123;name:'cd'，age:33&#125; &#123;name:'pol'，age:5&#125;] 如果我们想把这个数组里面的name提取出来组成一个数组，可以这样做123var nameList = jobs.map(function(item， index， array)&#123; return item.name&#125;) Array.prototype.reduce()这个方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。也就是说是一种迭代器，另一种意义上的for循环，它传给callback函数的参数有四个，分别是previousValue 上一次调用回调返回的值，或者是提供的初始值（initialValue）currentValue 数组中当前被处理的元素index 当前元素在数组中的索引array 调用 reduce 的数组另外reduce还可以接受一个初始值举个例子123[1，2，3，4].reduce(function(previousValue， currentValue， index， array)&#123; return previousValue + currentValue&#125;) 其结果就是把数组里面的值求和，结果是10，如果给redece加一个初始值123[1，2，3，4].reduce(function(previousValue， currentValue， index， array)&#123; return previousValue + currentValue&#125;，5) 这样子结果就是15 MathMath是js自带的一个数学库，可以方便的做各种计算，我们编码过程中可以巧妙借用他来实现功能，避免冗余的代码。 Math.max看名字你们也知道和Math.min对应，求最大值，简单的用法是直接传值1console.log(Math.max(1，2，4，5，6，7)) //输出7 但是如果我们用于数组，就可以很简单的求出一个数组里面的最大值（或者最小值）123var array = [44，12，42，11，87，33，49，3，487，111]var maxNum = Math.max.call(Math， array)console.log(maxNum) //输出487 Math.min和Math.max用法相同，不再赘述 结语函数式编程还有很多用法，这只是第一篇，我会在以后的文章里面介绍更多的用法。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Math</tag>
        <tag>函数式编程</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postman奇技淫巧]]></title>
    <url>%2F2016%2F10%2F22%2Fpostman%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[postman是chrome浏览器应用市场里面的一款神器，测试人员的好帮手，黑客手里的爬虫利器。 postman介绍postman是一个用来方便构造各种各样网络请求的工具，他的平台是构建在chrome上的。因为强大有用的功能被封为神器，可惜没有中文支持，让很多初学者望而却步，但是只要坚定的去摸索使用这个工具，你就会感受到他的强大而且丰富的功能。本文打算简单的介绍下基本使用功能，postman里面的功能非常丰富，一篇文章是说不完的，所以我打算主要说一说我在使用postman中的一些心得，发现的一些小技巧。 使用前的准备在学习使用前你需要知道以下几个小知识： postman的基本原理不是用我们平常熟知的，用js去构建XHR这种前端发送请求的方法去构建数据包的，因为他是chrome里面的应用，chrome给应用提供了许多接口，其中就包含了sockets接口（文档在这里），这个接口支持TCP和UDP协议，使得chrome应用网络通信成为可能，所以postman是使用chrome里面的接口，把chrome当作网络爬虫一样的工具来实现发送数据包的，所以我们要把他当作一个独立的应用程序来看待。 postman是一个chrome应用而不是chrome插件，定位不同所以功能是有区别的。 chrome应用市场地址 使用插件不需要翻墙，但是应用需要登录才能用，登录需要翻墙，翻墙手段自己摸索:) postman基本用法首先看整个界面，图1图11 Runner 测试人员用来进行集成化测试的功能，要配合Collections使用2 用来传递测试数据的，就是用户之间分享构建好的测试数据包3 History 记录测试历史，每一次发送数据包就会产生一个历史数据4 Collections 用来保存你构建好的数据包，登录用户且在翻墙的情况下，会自动同步你的数据，当然可以仔设置里面关掉5 我们主要的工作环境-构建器，稍后会详细说明6 配合postman的另一个chrome插件，注意是插件，其作用是接受来自目标服务器的cookies7 postman设置，可以设置操作习惯，主题和同步等等 postman构建器的基本使用下面我们就先来尝试构建一个数据包这里我们用来做实验的例子是向多说发送请求获取文章的评论数，以及转发数相关的API文档在这里 从文档我们知道有以下几个要点： 请求地址是http://api.duoshuo.com/threads/counts.json（可选有json或者jsonp） 请求方式是GET 需要两个参数，一个short_name，一个threads 不需要登录 我在这里可以提供下测试数据 short_name:jackfred threads:2016/10/22/postman奇技淫巧/ ok,让我们现在开始搞事情 见图21 选择请求方式GET2 填入地址 见图31 点击2 填入参数 最后我们点击Send按钮，成功！我们看到有一个评论，一个喜欢，对比下结果是正确的（喜欢是我自己点的，怎么啦） 奇技淫巧（重点）前面我们已经学会了怎么构造一个简单的测试数据，先不要慌着关掉窗口，重点来了，postman为用户提供了一个非常贴心的功能因为postman可以非常详细的自定义数据包，构建headers cookies 包括各种登录Authorization，如果我们想用各种编程语言构建一个一模一样的数据，肯定免不了要各种编写调试一下，在这里postman提供了一个非常让人暖心的功能点击这里我们发现postman竟然可以为你提供各种语言版本构建器的代码！点击左上角可以切换语言！如图，nodejs的构建器代码 这样我们就能很方便的去把这些代码选择粘贴到我们的工作环境中，而且不用担心代码有问题！ 文章到这里就结束了，postman还有很多强大的功能等你发掘，以后我也许还会在以后的文章理继续介绍postman :)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>chrome应用</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame 动画(一)]]></title>
    <url>%2F2016%2F10%2F21%2FrequestAnimationFrame-%E5%8A%A8%E7%94%BB-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[让我们写点能动的东西吧!今天让我们写点有趣的东西，用js实现动画 动画的定义在维基百科里面，动画是这样定义的: 动画是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。 也就是说每秒播放的画面张数决定了动画的流畅度，下面图1是每秒10帧的动画，图2是每秒2帧的动画图1图2 可以看到图1明显比图2的小球运动的流畅了很多，我们在js中也能实现类似的效果根据最新的官方标准，画面更新的频率至少要达到每秒60次才能让肉眼感受到流畅的动画效果，即每一张画面占用时间是1000/60=16.6666ms 使用setTimeout实现动画在以前我们要实现一个动画，可能要借助与js的定时函数setTimeout来实现，即类似下面的代码 1234setTimeout(function() &#123; // do something here setTimeout(arguments.callee)&#125;，1000/60) 这样子的缺点是有的，setTimeout不会立即执行，用过setTimeout的同学都知道，如果给setTimeout设置200ms后执行，通常需要等待大于200ms的时间函数才会被执行，这就造成了卡顿(原因:setTimeout中的定时器并不是准确的时间，实际中它需要在执行完前面的函数后才定时执行) 使用requestAnimationFrame来实现动画在最新的标准里面，js为我们提供了一个专门用来执行动画的函数 requestAnimationFrame ，调用它可以很完美的让函数在1000/60ms时执行，当然对应的自然有cancelAnimationFrame函数来取消执行动画现在我们就用他来实现一个简单的让小球运动的动画:12345678var ball = document.getElementsByTagName('div')[0];ball.style.left = getComputedStyle(ball)['left']; //设置好小球的初始值requestAnimationFrame(function() &#123; ball.style.left = (parseFloat(ball.style.left) + 5) +'px'; if (parseFloat(ball.style.left) &lt; 500) &#123; requestAnimationFrame(arguments.callee) &#125;&#125;) 点击这里预览效果 小例子是不是很流畅?其实如果要说教程的话，到这里是可以结束了，很多很炫目的效果其实都是这些基础的代码搭建起来的，里面会涉及到很多数学知识，只要能理解清楚其中的数学原理，就可以很轻松的实现各种效果，最后让我们实现一个文章里面图1的效果，一个弹跳的小球在此之前，我们要了解以下几个要点: 小球升起时候做减速运动，落下的时候做加速运动 小球如果从地面开是运动，肯定有一个向上的初速度 用requestAnimationFrame控制速度的话，在小球接触地面的时候，要将速度重置成原来的向上的速度 好，以下就是成果代码:12345678910111213var ball = document.getElementsByTagName('div')[0];var beginSpeed = 20，speed = 20，a = 0.5;// 设置好小球的初始速度，现速度和加速度var beginHeight = getComputedStyle(ball)['top']ball.style.top = beginHeight; //设置好小球的初始值requestAnimationFrame(function() &#123; ball.style.top = (parseFloat(ball.style.top) - speed) +'px'; speed = speed - a; if (parseFloat(ball.style.top) &gt;= 500) &#123; //小球回落地面的时候，重置高度和速度 ball.style.top = beginHeight; speed = beginSpeed; &#125; requestAnimationFrame(arguments.callee)&#125;) 点击这里预览效果]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>js动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客是不是要说一句hello world?]]></title>
    <url>%2F2016%2F10%2F18%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[从开始工作到现在，已经过去了两年。直到现在才决定开一个博客，记录平常的工作经验和想法。 这是一个不断会被编辑的文章，里面会有我对程序员这个职业的思考。 16/10/20 很多人觉得程序员是一个非常考验脑力的工作，其实我觉得在这个世界上，不管是国内外的，都有不动脑的程序员和动脑子的程序员两种。 一种程序员或许处于对于技术的热爱，或者对于一个更好的工作岗位的期待，不断的去主动学习，内心有各种各样的理由去驱动他去学习。因为他知道，在程序员这个世界里面，技术代表一切。 还有一种是传统行业里面类型的程序员，搞好自己手中的活，踏踏实实做好手边的事，每天被老婆孩子上司烦得受不了，根本没心思去管其他事。 我们或多或少的可能会从第一种程序员过渡到第二种，也有不少人可能一直做第一种或者第二种程序员，没有必要分辨哪种好哪种不好，大多数情况下，我们更多需要考虑的是，自己的职业规划。 也许我们有一天，会老的写不了代码了，更不上新的技术了，在那一天来临之前，我们做好准备了吗?]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
</search>
