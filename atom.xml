<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jackfred的博客</title>
  
  <subtitle>人啊,就是需要一点亮剑精神</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jackfred.cn/"/>
  <updated>2019-11-21T06:41:33.497Z</updated>
  <id>http://www.jackfred.cn/</id>
  
  <author>
    <name>周康</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PWA初尝试</title>
    <link href="http://www.jackfred.cn/2019/11/21/PWA/"/>
    <id>http://www.jackfred.cn/2019/11/21/PWA/</id>
    <published>2019-11-21T06:02:19.000Z</published>
    <updated>2019-11-21T06:41:33.497Z</updated>
    
    <content type="html"><![CDATA[<p>PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。<br><a id="more"></a><br>具体的介绍，以及详细的教程，请看<a href="https://lavas.baidu.com/pwa/README" target="_blank" rel="noopener">这里</a>，我在这里就不在重复造轮子了<br>这里我就简单的介绍下我在本博客网站下搭建PWA的具体步骤，让同学们按照我最简单的教程来个快速启动</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>想要成功搭建并运行一个完整的PWA应用，你需要以下几个条件：</p><ul><li>站点部署 manifest.json，该文件需配置如下属性：</li></ul><ol><li>short_name （用于主屏幕显示）</li><li>name （用于安装横幅显示）</li><li>icons （其中必须包含一个 mime 类型为 image/png 的图标声明）</li><li>start_url （应用启动地址）</li><li>display （必须为 standalone 或 fullscreen）</li></ol><ul><li>站点注册 Service Worker。</li><li>站点支持 HTTPS 访问（或者在本地环境127.0.0.1或localhost下）。</li><li>站点在同一浏览器中被访问至少两次，两次访问间隔至少为 5 分钟。<h1 id="ServiceWorker-js安装"><a href="#ServiceWorker-js安装" class="headerlink" title="ServiceWorker.js安装"></a>ServiceWorker.js安装</h1>首先在主页html上注册<code>ServiceWorker.js</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        navigator.serviceWorker.register(<span class="string">'/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册成功</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful with scope: '</span>, registration.scope);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册失败:(</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在<code>sw.js</code>中的内容是这样的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 来来来，代理可以搞一些代理的事情</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 Service Worker 有自己的返回，就直接返回，减少一次 http 请求</span></span><br><span class="line">            <span class="keyword">if</span> (response) &#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 service worker 没有返回，那就得直接请求真实远程服务</span></span><br><span class="line">            <span class="keyword">var</span> request = event.request.clone(); <span class="comment">// 把原始请求拷过来</span></span><br><span class="line">            <span class="keyword">return</span> fetch(request).then(<span class="function"><span class="keyword">function</span> (<span class="params">httpRes</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// http请求的返回已被抓到，可以处置了。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求失败了，直接返回失败的结果就好了。。</span></span><br><span class="line">                <span class="keyword">if</span> (!httpRes || httpRes.status !== <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> httpRes;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求成功的话，将请求缓存起来。</span></span><br><span class="line">                <span class="keyword">var</span> responseClone = httpRes.clone();</span><br><span class="line">                caches.open(<span class="string">'my-test-cache-v1'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                    cache.put(event.request, responseClone);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> httpRes;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="设置manifest-json文件"><a href="#设置manifest-json文件" class="headerlink" title="设置manifest.json文件"></a>设置manifest.json文件</h1><p>首先在主页html文件下引入<code>manifest.json</code>文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>manifest.json</code>文件中内容的填写<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"short_name"</span>: <span class="string">"Jackfred"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Jackfred的博客"</span>,</span><br><span class="line">    <span class="attr">"icons"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"src"</span>: <span class="string">"/favicon96.png"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"image/png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span>: <span class="string">"96x96"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"src"</span>: <span class="string">"/favicon144.png"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"image/png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span>: <span class="string">"144x144"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"src"</span>: <span class="string">"/favicon188.png"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"image/png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span>: <span class="string">"188x188"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"display"</span>: <span class="string">"minimal-ui"</span>,</span><br><span class="line">    <span class="attr">"theme_color"</span>: <span class="string">"black"</span>,</span><br><span class="line">    <span class="attr">"start_url"</span>: <span class="string">"index.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，PWA的部署就结束了，为了应对不同分辨率的手机，我们可能需要不同尺寸的图标，在我部署测试的时候发现，谷歌浏览器要求<br>至少需要一个144x144尺寸的图标，请各位同学注意。</p><h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p>请大家用手机扫下面的二维码<br><img src="/images/pwa/url.gif" alt="qr"><br>或者直接点击这个链接<a href="https://www.jackfred.cn/">https://www.jackfred.cn/</a><br>因为我站点证书是直接用的github的证书，所以，部分手机浏览器会显示证书不安全或者不是私密链接等内容，请忽略ヾ(。￣□￣)ﾂ゜゜゜<br>根据PWA的设计原则，我们可以自己主动点击浏览器菜单页，会发现多了一个添加到主屏幕的选项，也可以分2次访问网站（间隔要5分钟以上），手机屏幕下方就会自动弹出提示安装站点的横幅，点击即可添加<br><img src="/images/pwa/t.png" alt="result"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="PWA" scheme="http://www.jackfred.cn/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Vue3的新特性Function-api</title>
    <link href="http://www.jackfred.cn/2019/09/25/vue3-function-api/"/>
    <id>http://www.jackfred.cn/2019/09/25/vue3-function-api/</id>
    <published>2019-09-25T05:40:18.000Z</published>
    <updated>2019-11-21T01:35:50.637Z</updated>
    
    <content type="html"><![CDATA[<p>最近（实际上已经几个月了）vue社区关于vue3的新特性一事一直闹得沸沸扬扬的，我因为公司以及家庭原因已经好久没有更博了（咕咕咕），最近了解了一下相关的内容，现在简单的解释一下Vue3的这个新特性，以及为什么尤雨溪大佬要力排众议坚持这么做。<br><a id="more"></a><br>在这里先贴一下<a href="https://github.com/vuejs/rfcs/blob/function-apis/active-rfcs/0000-function-api.md#type-issues-with-class-api" target="_blank" rel="noopener">官方对此的解释</a>，英语好的同学可以直接看这个，解释的更详细。懒得看的同学继续听我说。</p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>React在近期做出了一个重大更新<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React Hooks</a>，在这个更新中React提出了一个重要的解决方案（或者说编码思维？），然后众所周知，Vue一直是一个能够吸取Angular和React等优秀框架优点，博众人之长的框架。<br>所以尤雨溪大佬就再次也跟进吸取了这个特性。</p><h2 id="React-Hooks提出了什么思想？"><a href="#React-Hooks提出了什么思想？" class="headerlink" title="React Hooks提出了什么思想？"></a>React Hooks提出了什么思想？</h2><p>简单来说，就是因为React的运行机制（生命周期思想），改变了我们传统的编写组件逻辑的方式。<br>想要实现一个效果，我们可能需要把一个有完整逻辑的操作拆分放到不同的生命周期函数中。<br>例如我们经常会在componentDidMount函数中监听事件，然后在componentWillUnmount函数中清楚监听。<br>这样的写法，拆分了一个完整的组件逻辑，并把这些拆分掉的逻辑与其他逻辑放在了一起，对于代码的可读性上以及理解上变得更加难懂，组件之间的状态逻辑也难以复用。</p><p>基于此原因，在加上React官方对国际标准中class一直都没有没有稳定的语法提案的失望，所以打算采取渐进策略，开始关注并加入Function-api模式</p><h1 id="Function-api模式主要的变化是什么？"><a href="#Function-api模式主要的变化是什么？" class="headerlink" title="Function-api模式主要的变化是什么？"></a>Function-api模式主要的变化是什么？</h1><p>在vue3中，提供了一个setup函数，在这个函数中，你可以把所有的组件逻辑都写在这里，而不用想以前一样，需要把状态放在data函数，相关逻辑放在生命周期函数等等。<br>一下是官方的一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMouse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = value(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = value(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    x.value = e.pageX</span><br><span class="line">    y.value = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in consuming component</span></span><br><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = useMouse()</span><br><span class="line">    <span class="keyword">const</span> &#123; z &#125; = useOtherLogic()</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y, z &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>组件数据value(0)来存取，生命周期函数也直接在setup函数中执行了，对应vue2中的一些特性比如watch也提供了函数式的表达。这其中还有一些细节变化，我们不做详细讨论。</p><p>在这里可以做个简单的概括，vue2中我们的书写方式叫option-api，在vue3中，这些类似的属性配置都提供了函数式的书写方式，这就是Function-api。</p><h1 id="这样不会让开发代码变得更加混乱了吗？"><a href="#这样不会让开发代码变得更加混乱了吗？" class="headerlink" title="这样不会让开发代码变得更加混乱了吗？"></a>这样不会让开发代码变得更加混乱了吗？</h1><p>以下是官方对此的解释的大概翻译（英文水平有限，只做概括翻译）：  </p><blockquote><p>我收到一些反馈，他们觉得新手会在这个模式下写出意大利面条式的代码，我认为这些担忧是毫无根据的，Function-api模式确实比以往的模式更加的灵活，但是Function-api模式可以把你的组件逻辑写在一个封密的函数中，传统的模式会把你的组件逻辑分到props 、data()、mounted等属性中，如果你把这个组件放到你的app中，他将会变成一个怪物，组件的逻辑像碎片一样散布在每个角落，而Function-api模式则把这些逻辑组织在setup函数中，避免了这种问题发生。</p></blockquote><p>原文链接<a href="https://github.com/vuejs/rfcs/blob/function-apis/active-rfcs/0000-function-api.md#spaghetti-code-in-unexperienced-hands" target="_blank" rel="noopener">在这</a>，大概意思就是这样，虽然我觉得尤雨溪大佬并没有直面回答问题。。。</p><h1 id="这个模式是不是意味着如果我要升级我的项目，就要改写代码？"><a href="#这个模式是不是意味着如果我要升级我的项目，就要改写代码？" class="headerlink" title="这个模式是不是意味着如果我要升级我的项目，就要改写代码？"></a>这个模式是不是意味着如果我要升级我的项目，就要改写代码？</h1><p>不是，Function-api是向上兼容的，是一个可选选项，从vue2升级到vue3不需要改写任何代码。</p><h1 id="那会一直保持这种兼容吗？"><a href="#那会一直保持这种兼容吗？" class="headerlink" title="那会一直保持这种兼容吗？"></a>那会一直保持这种兼容吗？</h1><p>目前会（言下之意就是未来不会），至少在这篇<a href="https://github.com/vuejs/rfcs/blob/function-apis/active-rfcs/0000-function-api.md#is-this-set-in-stone" target="_blank" rel="noopener">RFC文档</a>中</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>拥抱未来总归是一件好事，作为一个优秀的框架，必然要跟上最新的技术和思想（虽然他越来越像React了。。），各位用惯了vue2的老程序员也不必不适应，毕竟现在前端就是这样的，还是处于变动的时代。  </p><blockquote><p>求求你，我实在学不动了.jpg  </p></blockquote><p>哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近（实际上已经几个月了）vue社区关于vue3的新特性一事一直闹得沸沸扬扬的，我因为公司以及家庭原因已经好久没有更博了（咕咕咕），最近了解了一下相关的内容，现在简单的解释一下Vue3的这个新特性，以及为什么尤雨溪大佬要力排众议坚持这么做。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Vue" scheme="http://www.jackfred.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Google的动画技术Flip初探</title>
    <link href="http://www.jackfred.cn/2019/09/25/Google-flip-animation/"/>
    <id>http://www.jackfred.cn/2019/09/25/Google-flip-animation/</id>
    <published>2019-09-25T04:18:04.000Z</published>
    <updated>2019-11-21T01:35:50.634Z</updated>
    
    <content type="html"><![CDATA[<p>最近对Vue的<code>&lt;transition-group&gt;</code>的动画效果感兴趣，于是研究了一下实现原理。<br><a id="more"></a><br>在官方文档中，内部的实现，是Vue 使用了一个叫 FLIP 简单的动画队列，一个来自谷歌官方的动画技术。<br>搜了一下国内的博客，发现对其介绍非常的少（实际上就只有1篇，剩下的都是互相抄，换汤不换药）<br>在一番摸索后，我大概了解了这个技术，下面尽量用简单的语言说一下Flip的原理和使用。</p><h1 id="什么是Flip？"><a href="#什么是Flip？" class="headerlink" title="什么是Flip？"></a>什么是Flip？</h1><p>简单来说，就是在css动画中，除了 transform 和 opacity 之外的动画开销都比较大（包括left、top等定位元素），动画会有一点迟滞，因为浏览器必须递归检查其他元素的布局是否因此而改变。<br>所以Flip就是一个仅仅通过transform这个属性来实现流畅无延时的动画的技术。</p><h1 id="Flip的实现原理"><a href="#Flip的实现原理" class="headerlink" title="Flip的实现原理"></a>Flip的实现原理</h1><p>简单来说，Flip就是记录一个元素变化前和变化后的状态,然后再通过js模拟重播这一动画过程，（注：Flip的技术思维还可以用作更高级的动画运用，这篇文章只探讨初级的运用）<br>这里记录元素的状态包括元素的位置的长宽。<br>Flip是First, Last, Invert, Play的缩写，引用一下官方对此的解释。</p><ul><li>First 元素的初始状态。 在发生任何事情之前，记录将要过渡的元素的当前（即，first）位置和尺寸。 可以使用element.getBoundingClientRect() 来做到这一点，如下所示。</li><li>Last 执行导致过渡瞬时发生的代码，并记录元素的最后（即 last）位置和尺寸。</li><li>Invert 由于元素处于最后位置，所以我们希望通过使用transform修改其位置和尺寸来创建它处于第一位置的错觉。这需要一点数学，但不是太困难。</li><li>Play 将元素倒置（假装在第一个位置），我们可以通过将其 transform 设置为 none，将其移回到最后位置。</li></ul><h1 id="官方Flip使用教程"><a href="#官方Flip使用教程" class="headerlink" title="官方Flip使用教程"></a>官方Flip使用教程</h1><p>因为官方没有正式的文档，只有demo和视频教程（这一点有点让人无语。。）而demo实现的效果虽然很赞，但是代码太多了，实现的复杂，对于初学者不是很友好，所以我在这里做个最简单的演示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://raw.githubusercontent.com/googlearchive/flipjs/master/dist/flip.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">.hide-box&#123;</span></span><br><span class="line"><span class="undefined">    display: none;</span></span><br><span class="line"><span class="undefined">    width: 200px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">.flip-box&#123;</span></span><br><span class="line"><span class="undefined">    width: 200px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    font-size: 40px;</span></span><br><span class="line"><span class="undefined">    line-height: 200px;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">    font-weight: bold;</span></span><br><span class="line"><span class="undefined">    box-shadow: 0 0 7px 1px rgba(222, 222, 222, 0.9);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hide-box"</span> <span class="attr">id</span>=<span class="string">"hide"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flip-box"</span> <span class="attr">id</span>=<span class="string">"flip"</span>&gt;</span>Flip<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在这里我们引入了官方的Flip.js，然后创建了两个div，一个是实验对象flip-box，还有一个在其文档流上方的隐藏div<br>效果图：<br><img src="/images/flip/flip.png" alt="flip"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hidebox = <span class="built_in">document</span>.querySelector(<span class="string">"#hide"</span>);</span><br><span class="line"><span class="keyword">var</span> flipbox = <span class="built_in">document</span>.querySelector(<span class="string">"#flip"</span>);</span><br><span class="line"><span class="keyword">let</span> flip = <span class="keyword">new</span> FLIP(&#123;  <span class="comment">//初始化</span></span><br><span class="line">    element: flipbox,</span><br><span class="line">    duration: <span class="number">500</span></span><br><span class="line">&#125;);</span><br><span class="line">flip.first(); <span class="comment">//记录flipbox的初始状态</span></span><br><span class="line">hidebox.style.display = <span class="string">"block"</span>;<span class="comment">// 能够引起flipbox位置和形状变化的操作</span></span><br><span class="line">flip.last(); <span class="comment">//记录被挤下去的flipbox的状态</span></span><br><span class="line">flip.invert();  <span class="comment">//还原flipbox的初始状态</span></span><br><span class="line">flip.play(); <span class="comment">//播放动画</span></span><br></pre></td></tr></table></figure></p><p>这里我们直接让隐藏的div显示，下面的flipbox会被挤下去，这里是效果图：<br><img src="/images/flip/flip.gif" alt="flip"><br>我们注意到这里动画是平滑过渡过去的，可能比较单调，官方在这里预留了运动曲线函数，可以高度自定义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flip = <span class="keyword">new</span> FLIP(&#123;</span><br><span class="line">  element: target,</span><br><span class="line">  easing: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t * t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="如何在react和vue中使用"><a href="#如何在react和vue中使用" class="headerlink" title="如何在react和vue中使用"></a>如何在react和vue中使用</h2><p>基于Flip的思想，我们发现实际上和现有的主流框架的生命周期思想是不谋而合的，所以使用起来也非常容易。<br>只需要在元素初始生命周期调用Flip记录状态，在元素更新时的生命周期记录并播放即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line">    flip.first();</span><br><span class="line">&#125;,</span><br><span class="line">updated()&#123;</span><br><span class="line">    flip.last();</span><br><span class="line">    flip.invert();</span><br><span class="line">    flip.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以直接封装成一个mixin文件，这样就可以在我们需要动画的元素上一键加上动画效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对Vue的&lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;的动画效果感兴趣，于是研究了一下实现原理。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="js动画" scheme="http://www.jackfred.cn/tags/js%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序的知识补充和答疑</title>
    <link href="http://www.jackfred.cn/2019/04/17/wechat-css/"/>
    <id>http://www.jackfred.cn/2019/04/17/wechat-css/</id>
    <published>2019-04-17T01:04:47.000Z</published>
    <updated>2019-11-21T01:35:50.637Z</updated>
    
    <content type="html"><![CDATA[<p>通过9节课培训的结果，了解到了部分同学还存在某些小程序相关的疑问，在这里补充一下相关的知识，以及答疑。<br><a id="more"></a></p><h1 id="布局问题"><a href="#布局问题" class="headerlink" title="布局问题"></a>布局问题</h1><p>在这里我们主要讨论行内元素、块级元素、以及行内块级元素，元素的浮动在小程序里面会有怪异的表现，这里就不讨论了</p><p>行内元素会在一条直线上排列（默认宽度只与内容有关），都是同一行的，水平方向排列。<br>块级元素各占据一行（默认宽度是它本身父容器的100%（和父元素的宽度一致），与内容无关），垂直方向排列。块级元素从新行开始，结束接着一个断行。<br>行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。<br>而行内块级元素即可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'ha'</span>&gt;</span>行内元素a<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'hb'</span>&gt;</span>行内元素设置了宽高b<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'ka'</span>&gt;</span>块级元素a<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'kb'</span>&gt;</span>块级元素设置了宽高b<span class="tag">&lt;/<span class="name">view</span>&gt;</span><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'oa'</span>&gt;</span>行内块级元素a<span class="tag">&lt;/<span class="name">view</span>&gt;</span><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'ob'</span>&gt;</span>行内块级元素b<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ha</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hb</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ka</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.kb</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.oa</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ob</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ka</span>,<span class="selector-class">.kb</span>,<span class="selector-class">.oa</span>,<span class="selector-class">.ob</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/weixinxiaochenxu/block.png" alt="微信小程序"></p><p>在上一节课，有同学问我，有时候设计图，想让一个元素居右，要怎么写，虽然小程序里面float不好用，但是想实现的方法还是有很多的，先结合本篇文章说一个方法<br>第一种方法，通过填充的方式使元素居右<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'b'</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种，巧用行内元素的text-align属性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'b'</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法，就是使用flex布局实现，具体知识可以看我以前的文章<a href="http://www.jackfred.cn/2019/01/22/flex-mobile/">flex布局</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'b'</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h1><p>在小程序中，全局环境下，this指向的是undefined（与js不同）<br>当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  prop: <span class="number">37</span>,</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// logs 37</span></span><br></pre></td></tr></table></figure></p><p>当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是作为‘this’使用的对象</span></span><br><span class="line"><span class="comment">// 后续参数作为参数传递给函数调用</span></span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br></pre></td></tr></table></figure></p><p>想了解更多关于this的知识，可以看看我以前的文章：<a href="http://www.jackfred.cn/2016/10/26/js%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E6%84%8F%E4%B9%89/">js的继承</a></p><h1 id="wxs用法"><a href="#wxs用法" class="headerlink" title="wxs用法"></a>wxs用法</h1><p>这是对于小程序方面知识介绍的最后一点补充<br>wxs是在小程序中一个比较鸡肋的功能（个人见解），其作用就是可以让你在wxml文件中插入js脚本，js脚本需要统一的通过module.exports来输出一个对象或者值。在后面的代码中则可以调用它。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    test:function(a)&#123;</span><br><span class="line">        return a + ' test';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;test.test(data)&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个功能不能从上下文中获取页面的数据，只能内部自定义一些数据，使用上和声明一个函数没什么区别，而且插在wxml文件中还会增加代码的混乱度，所以我觉得是个比较鸡肋的功能，但是在微信小程序官方文档里，它依旧给了不少的篇幅介绍，所以我在这里补充一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过9节课培训的结果，了解到了部分同学还存在某些小程序相关的疑问，在这里补充一下相关的知识，以及答疑。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="微信小程序" scheme="http://www.jackfred.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序的登录与分享</title>
    <link href="http://www.jackfred.cn/2019/04/11/miniprogram-share-and-login/"/>
    <id>http://www.jackfred.cn/2019/04/11/miniprogram-share-and-login/</id>
    <published>2019-04-11T05:41:08.000Z</published>
    <updated>2019-11-21T01:35:50.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>从微信官方给的文档上给的图看，有点复杂，让人头昏眼花，实际上我们只要理清流程，整个过程并不难。<br><a id="more"></a><br><img src="/images/weixinxiaochenxu/api-login.jpg" alt="微信小程序"></p><p>首先需要调用微信的登录接口，拿到code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.code) &#123;</span><br><span class="line">      <span class="comment">// 发起网络请求</span></span><br><span class="line">      <span class="built_in">console</span>.log(res.code)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'登录失败！'</span> + res.errMsg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后发送code里的数据到对应的后台<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">    url: <span class="string">'loginurl'</span>, <span class="comment">//你对应后台的登录地址</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        code: res.code</span><br><span class="line">    &#125;,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>后台拿到数据与微信后台交互解密，返回解密数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"openid"</span> : <span class="string">"otsAA5dH45UrTJaBXi-tOemf1-dg"</span>,</span><br><span class="line">    <span class="attr">"user_3rdsession"</span> : <span class="string">"a85d4520e4df47f139c7dd718c179df9"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"normal"</span> //第三方后台自定义状态数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小程序拿到数据，存入localstorage<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.setStorageSync(</span><br><span class="line">  <span class="string">'userInfo'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">      data:<span class="string">'data'</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>封装网络请求函数，在每次发送请求时，使用getStorageSync取出数据，带上数据发送出去，小程序设置用户在没有操作的情况下session过5分钟就会过期，所以需要处理好过期情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax_curl</span>(<span class="params">url, data, cb, posttype = <span class="string">'get'</span>, func_fail</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userInfo = wx.getStorageSync(<span class="string">'userInfo'</span>);</span><br><span class="line">  data = <span class="built_in">Object</span>.assign(data, userInfo); <span class="comment">//合并对象</span></span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    data: data,</span><br><span class="line">    <span class="comment">// method: method_type,  忽略细节</span></span><br><span class="line">    <span class="comment">// header: &#123;</span></span><br><span class="line">    <span class="comment">//   'Content-Type': headerset</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">typeof</span> cb == <span class="string">"function"</span> &amp;&amp; cb(res.data.data);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (res.data.code == <span class="number">-999</span>) &#123; <span class="comment">//检测下线，重新登录</span></span><br><span class="line">        login(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          data.user_3rdsession = wx.getStorageSync(<span class="string">'userInfo'</span>).user_3rdsession</span><br><span class="line">          ajax_curl(url, data, cb, posttype);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">typeof</span> func_fail == <span class="string">"function"</span> &amp;&amp; func_fail(res);</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">          title: res.message,</span><br><span class="line">          icon: <span class="string">'none'</span>,</span><br><span class="line">          duration: <span class="number">2000</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h1><p>小程序的分享有两种形式，一个是通过按钮<strong>button</strong>转发，一个是通过右上角的菜单按钮转发。<br>按钮转发需要设置button组件中的open-type属性，此处需要页面设置Page.onShareAppMessage事件才能出发<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">"share"</span>&gt;</span>分享<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>菜单转发就简单很多，只需要在当前页里设置好onShareAppMessage事件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onShareAppMessage(res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.from === <span class="string">'button'</span>) &#123;</span><br><span class="line">      <span class="comment">// 来自页面内转发按钮,如果是来自菜单则是menu</span></span><br><span class="line">      <span class="built_in">console</span>.log(res.target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">'自定义转发标题'</span>,</span><br><span class="line">      path: <span class="string">'/page/user?id=123'</span>,</span><br><span class="line">      imageUrl:<span class="string">''</span> <span class="comment">//可选</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="在微信开发者编辑器中模拟打开分享小程序的场景"><a href="#在微信开发者编辑器中模拟打开分享小程序的场景" class="headerlink" title="在微信开发者编辑器中模拟打开分享小程序的场景"></a>在微信开发者编辑器中模拟打开分享小程序的场景</h2><p><img src="/images/weixinxiaochenxu/bianyi.png" alt="微信小程序"><br><img src="/images/weixinxiaochenxu/bianyi2.png" alt="微信小程序"><br>选择好启动页面，为你分享的那个页面路径，设置好你的启动参数，就可以模拟分享小程序的场景</p><h2 id="获取群内转发的一些信息shareTicket"><a href="#获取群内转发的一些信息shareTicket" class="headerlink" title="获取群内转发的一些信息shareTicket"></a>获取群内转发的一些信息shareTicket</h2><p>首先需要使用微信的接口开放shareTicket的设置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.showShareMenu(&#123;</span><br><span class="line">  withShareTicket: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在转发的过程中，其他用户打开转发的小程序时，可以通过在 App.onLaunch 或 App.onShow 获取到一个 shareTicket<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params">opt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(opt.shareTicket) <span class="comment">//一个字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>注意，这里可以用我们刚刚学到的知识来模拟分享场景，不过有一个小小的区别，看下图<br><img src="/images/weixinxiaochenxu/ddd.png" alt="微信小程序"><br>然后通过调用 wx.getShareInfo 接口传入此 shareTicket 可以获取到转发信息<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.getShareInfo(&#123;</span><br><span class="line">    shareTicket: app.globalData.tik,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>此处获取到的数据，实际上是包含加密字符串的对象，我们还需要将数据发送到对应的第三方服务器中解密，才能拿到正常的数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"nickName"</span>: <span class="string">"Band"</span>,</span><br><span class="line">  <span class="attr">"gender"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"language"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">  <span class="attr">"city"</span>: <span class="string">"Guangzhou"</span>,</span><br><span class="line">  <span class="attr">"province"</span>: <span class="string">"Guangdong"</span>,</span><br><span class="line">  <span class="attr">"country"</span>: <span class="string">"CN"</span>,</span><br><span class="line">  <span class="attr">"avatarUrl"</span>: <span class="string">"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;登录&quot;&gt;&lt;a href=&quot;#登录&quot; class=&quot;headerlink&quot; title=&quot;登录&quot;&gt;&lt;/a&gt;登录&lt;/h1&gt;&lt;p&gt;从微信官方给的文档上给的图看，有点复杂，让人头昏眼花，实际上我们只要理清流程，整个过程并不难。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="微信小程序" scheme="http://www.jackfred.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://www.jackfred.cn/2019/01/22/flex-mobile/"/>
    <id>http://www.jackfred.cn/2019/01/22/flex-mobile/</id>
    <published>2019-01-22T01:07:40.000Z</published>
    <updated>2019-11-21T01:35:50.634Z</updated>
    
    <content type="html"><![CDATA[<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><a id="more"></a><br><img src="/images/mobile-adaptive/bg2015071004.png" alt="flex"><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。</p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><h2 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h2><p>flex-direction属性决定主轴的方向（即项目的排列方向）。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mobile-adaptive/bg2015071005.png" alt="flex"></p><h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mobile-adaptive/bg2015071006.png" alt="flex"></p><h2 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h2><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h2><p>justify-content属性定义了项目在主轴上的对齐方式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mobile-adaptive/bg2015071010.png" alt="flex"></p><h2 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h2><p>align-items属性定义项目在交叉轴上如何对齐。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mobile-adaptive/bg2015071011.png" alt="flex"></p><h2 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h2><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mobile-adaptive/bg2015071012.png" alt="flex"></p><h1 id="容器成员的属性"><a href="#容器成员的属性" class="headerlink" title="容器成员的属性"></a>容器成员的属性</h1><h2 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h2><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mobile-adaptive/bg2015071013.png" alt="flex"></p><h2 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h2><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src="/images/mobile-adaptive/bg2015071014.png" alt="flex"></p><h2 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h2><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。<br><img src="/images/mobile-adaptive/bg2015071015.jpg" alt="flex"></p><h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该属性可能取6个值，除了auto，其他都与align-items属性完全一致。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/mobile-adaptive/bg2015071016.png" alt="flex"></p><h1 id="最后的例子和说明"><a href="#最后的例子和说明" class="headerlink" title="最后的例子和说明"></a>最后的例子和说明</h1><p>flex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况：</p><blockquote><p>auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。<br>content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。<br>百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: flex;</span></span><br><span class="line"><span class="undefined">        width: 600px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="undefined">        width: 140px;</span></span><br><span class="line"><span class="undefined">        flex: 2 1 0%;</span></span><br><span class="line"><span class="undefined">        background: blue;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line"><span class="undefined">        width: 100px;</span></span><br><span class="line"><span class="undefined">        flex: 2 1 auto;</span></span><br><span class="line"><span class="undefined">        background: darkblue;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line"><span class="undefined">        flex: 1 1 200px;</span></span><br><span class="line"><span class="undefined">        background: lightblue;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>主轴上父容器总尺寸为 600px<br>子元素的总基准值是：0% + auto + 200px = 300px，其中</p><ul><li>0% 即 0 宽度</li><li>auto 对应取主尺寸即 100px</li></ul><p>故剩余空间为 600px - 300px = 300px<br>伸缩放大系数之和为： 2 + 2 + 1 = 5<br>剩余空间分配如下：</p><ul><li>item-1 和 item-2 各分配 2/5，各得 120px</li><li>item-3 分配 1/5，得 60px</li></ul><p>各项目最终宽度为：</p><ul><li>item-1 = 0% + 120px = 120px</li><li>item-2 = auto + 120px = 220px</li><li>item-3 = 200px + 60px = 260px</li></ul><p>当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设<br>而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="移动端" scheme="http://www.jackfred.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>移动端开发教程（一）</title>
    <link href="http://www.jackfred.cn/2019/01/16/mobile-develop-teach/"/>
    <id>http://www.jackfred.cn/2019/01/16/mobile-develop-teach/</id>
    <published>2019-01-16T01:23:34.000Z</published>
    <updated>2019-11-21T01:35:50.636Z</updated>
    
    <content type="html"><![CDATA[<p>第一节课我们主要是讲解移动端前端开发viewport相关的概念和搭建基础<br><a id="more"></a></p><h1 id="viewport的概念"><a href="#viewport的概念" class="headerlink" title="viewport的概念"></a>viewport的概念</h1><p>在平常pc端开发的过程中，我们根据设计师给出的设计稿，按照设计稿里面每个元素的大小，在页面上用px这个单位按原样用css画出来，这在pc端开发是在正常不过的事，但是在手机上的移动端开发，我们却并不能这样。下面是一个例子。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">*&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pic</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 640px;</span></span><br><span class="line"><span class="undefined">height: 1136px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#FFE872</span>;</span></span><br><span class="line"><span class="undefined">color: white;</span></span><br><span class="line"><span class="undefined">font-size: 150px;</span></span><br><span class="line"><span class="undefined">text-align: center;</span></span><br><span class="line"><span class="undefined">line-height: 1136px;</span></span><br><span class="line"><span class="undefined">font-family: cursive; </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span> Yellow <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Iphone5手机的分辨率为640x1136，我们在这个页面中用css画出了一个像素为640x1136的黄色方块，按照直觉在手机上应该满屏显示。但是实际效果不是这样，如下图。<img src="/images/mobile-adaptive/mobile-iPhone.png" alt="iphone5"><br>我们看到黄色方块没有预想的那样占满整个屏幕。原因是什么呢？</p><h2 id="移动端1px并不等于设备的1px"><a href="#移动端1px并不等于设备的1px" class="headerlink" title="移动端1px并不等于设备的1px"></a>移动端1px并不等于设备的1px</h2><p>在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。</p><p>但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。</p><p>在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。</p><p>其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。</p><p>在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。下图为devicePixelRatio的兼容性在各个手机浏览器上的表现<br><img src="/images/mobile-adaptive/300958496962833.png" alt="devicePixelRatio的兼容性"></p><h2 id="利用viewport对手机缩放进行控制"><a href="#利用viewport对手机缩放进行控制" class="headerlink" title="利用viewport对手机缩放进行控制"></a>利用viewport对手机缩放进行控制</h2><p>关于viewport已经有大神对此有详细的研究（<a href="https://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="noopener">第一篇</a>，<a href="http://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="noopener">第二篇</a>，<a href="http://www.quirksmode.org/mobile/metaviewport/" target="_blank" rel="noopener">第三篇</a>），有兴趣的同学可以去看一下</p><p>我在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我的head标签中<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</p><p>meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。<br>meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">width        设置layout viewport  的宽度，为一个正整数，或字符串&quot;device-width&quot;</span><br><span class="line">initial-scale设置页面的初始缩放值，为一个数字，可以带小数</span><br><span class="line">minimum-scale允许用户的最小缩放值，为一个数字，可以带小数</span><br><span class="line">maximum-scale允许用户的最大缩放值，为一个数字，可以带小数</span><br><span class="line">height        设置layout viewport  的高度，这个属性对我们并不重要，很少使用</span><br><span class="line">user-scalable是否允许用户进行缩放，值为&quot;no&quot;或&quot;yes&quot;, no 代表不允许，yes代表允许</span><br></pre></td></tr></table></figure></p><h1 id="利用rem对不同移动端进行适配"><a href="#利用rem对不同移动端进行适配" class="headerlink" title="利用rem对不同移动端进行适配"></a>利用rem对不同移动端进行适配</h1><p>看一个例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.con &#123;</span><br><span class="line">      width: 10rem;</span><br><span class="line">      height: 10rem;</span><br><span class="line">      background-color: red;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/images/mobile-adaptive/555.png" alt="rem"><br>我们在修改一下html根元素的font-size<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    font-size: 25px;</span><br><span class="line">&#125;</span><br><span class="line">.con &#123;</span><br><span class="line">      width: 10rem;</span><br><span class="line">      height: 10rem;</span><br><span class="line">      background-color: red;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/images/mobile-adaptive/666.png" alt="rem"><br>由此我们可以知道rem的特性是根据根元素的font-size值来改变自身的值，我们可以给html设定不同的值，从而达到我们css样式中的适配效果。</p><p>例如我们要是在iPhone6下写一个元素来横向占满整个屏幕，那么代码可以这么写：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    font-size: 0.5px;</span><br><span class="line">&#125;</span><br><span class="line">.con &#123;</span><br><span class="line">      width: 750rem;</span><br><span class="line">      height: 10rem;</span><br><span class="line">      background-color: red;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>因为iPhone6的devicePixelRatio的值为2，在根据前面设置的meta，无缩放，我们可知道，在屏幕是1个物理像素为0.5个独立像素，所以设置font-size为0.5即可直接使用设计稿的尺寸。</p><p>但是这样只是适配了iPhone6，无法适配所有手机，所以在这里我们可以用js动态控制font-size<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio,</span><br><span class="line">meta = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"meta"</span>)[<span class="number">1</span>];</span><br><span class="line">meta.setAttribute(<span class="string">'content'</span>, <span class="string">'initial-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', maximum-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', minimum-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', user-scalable=no'</span>);</span><br><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">        resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">        recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">            <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">            docEl.style.fontSize = clientWidth / <span class="number">750</span> + <span class="string">'px'</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p><p>这段代码解决了几个痛点</p><blockquote><p>这样就可以完全按照视觉稿上的尺寸来了。</p></blockquote><blockquote><p>解决了图片高清问题。</p></blockquote><blockquote><p>解决了border 1px问题（我们设置的1px，在iphone上，由于viewport的scale是0.5，所以就自然缩放成0.5px）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一节课我们主要是讲解移动端前端开发viewport相关的概念和搭建基础&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="移动端" scheme="http://www.jackfred.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于vue在部分iPhone机型的微信浏览器中出现偶然乱码的bug</title>
    <link href="http://www.jackfred.cn/2018/09/04/iphone-wechat-charset-bug/"/>
    <id>http://www.jackfred.cn/2018/09/04/iphone-wechat-charset-bug/</id>
    <published>2018-09-04T08:36:20.000Z</published>
    <updated>2019-11-21T01:35:50.635Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个诡异的bug，在部分iPhone手机下，微信访问的网页出现了乱码<br><a id="more"></a></p><p>其他iPhone就没有这个问题，android手机也没有</p><p>于是定位了好久的问题，最终解决了，记录下</p><p>是因为框架用的是vue，在打包部署的时候，生成的index.html文件不符合h5规范，只要把index.html文件重新手写一遍就好了</p><p>虽然问题解决了，不过还是想吐槽一句：</p><h1 id="苹果真的很严格ヽ-o-皿′o-ﾉ"><a href="#苹果真的很严格ヽ-o-皿′o-ﾉ" class="headerlink" title="苹果真的很严格ヽ(ｏ`皿′ｏ)ﾉ"></a>苹果真的很严格ヽ(ｏ`皿′ｏ)ﾉ</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到一个诡异的bug，在部分iPhone手机下，微信访问的网页出现了乱码&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="bug" scheme="http://www.jackfred.cn/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>iframe嵌套页面滚动时jQuery的offset的值不准的bug</title>
    <link href="http://www.jackfred.cn/2018/03/05/jqueryOffsetBug/"/>
    <id>http://www.jackfred.cn/2018/03/05/jqueryOffsetBug/</id>
    <published>2018-03-05T03:25:47.000Z</published>
    <updated>2019-11-21T01:35:50.635Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下这几天遇到的一个诡异的bug<br><a id="more"></a><br>最近项目需求，要做一个气泡卡片的功能，因为不想引入新的库发生未知bug，于是自己手写了一个，定位通过jquery的offset方法来获取</p><p>项目的布局是通过iframe嵌套方式来布局的，结果发现在部分页面下，滚动后点击元素出现气泡，会发生气泡定位不准的情况<br><img src="/images/jqueryOffsetBug/popver.png" alt="popover"></p><p>经过多次debugger后确定不是我的代码问题，于是查看jquery的源码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">arguments</span>.length) <span class="keyword">return</span> e === t ? <span class="keyword">this</span> : <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        v.offset.setOffset(<span class="keyword">this</span>, e, t)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> n, r, i, s, o, u, a, f = &#123;</span><br><span class="line">            top: <span class="number">0</span>,</span><br><span class="line">            left: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        l = <span class="keyword">this</span>[<span class="number">0</span>],</span><br><span class="line">        c = l &amp;&amp; l.ownerDocument;</span><br><span class="line">    <span class="keyword">if</span>(!c) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">return</span>(r = c.body) === l ? v.offset.bodyOffset(l) : (n = c.documentElement, v.contains(n, l) ? (<span class="keyword">typeof</span> l.getBoundingClientRect != <span class="string">"undefined"</span> &amp;&amp; (f = l.getBoundingClientRect()), i = tr(c), s = n.clientTop || r.clientTop || <span class="number">0</span>, o = n.clientLeft || r.clientLeft || <span class="number">0</span>, u = i.pageYOffset || n.scrollTop, a = i.pageXOffset || n.scrollLeft, &#123;</span><br><span class="line">            top: f.top + u - s,</span><br><span class="line">            left: f.left + a - o</span><br><span class="line">        &#125;) : f)</span><br></pre></td></tr></table></figure></p><p>jquery中的offset的top是通过元素的getBoundingClientRect().top + window.scrollY - clientTop计算出来的。</p><p>这本来是没有什么问题的，但是上文提到过项目的整个页面是通过iframe来布局的，通过我不断的对比发现，window.scrollY在滚动的时候的值有时候会不正确，即在页面滚动的时候window.scrollY会少掉一个document.body.scrollTop的值。</p><p>我们只要在代码中加上这个值就可以修复这个bug </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下这几天遇到的一个诡异的bug&lt;br&gt;
    
    </summary>
    
    
      <category term="bug,jquery" scheme="http://www.jackfred.cn/tags/bug-jquery/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配讲解</title>
    <link href="http://www.jackfred.cn/2017/06/26/mobile-adaptive/"/>
    <id>http://www.jackfred.cn/2017/06/26/mobile-adaptive/</id>
    <published>2017-06-26T05:42:26.000Z</published>
    <updated>2019-11-21T01:35:50.636Z</updated>
    
    <content type="html"><![CDATA[<p>从乔布斯推出智能手机以来，市面上已经有各种各样的牌子不同大小的智能手机，手机的分辨率也各有不同，同时移动互联网的发展，移动端网页技术也开始被人重视，初次接触移动端的同学曾经可能也和我一样迷茫过，在公司要求做一些移动端的网页时，没有足够的移动开发经验和基础知识，慌忙的在网上选择“阿里移动端适配方案”或者“网易移动端适配方案”，网页做完了，可是还是会迷惑为什么传统的网页在不同的手机上表现都如此不同，还有rem是什么，viewport又是什么？<br>今天就带大家梳理一下知识点，打好基础的同时选择适合自己的开发方案。<br><a id="more"></a></p><h1 id="引入问题"><a href="#引入问题" class="headerlink" title="引入问题"></a>引入问题</h1><p>首先我们先看这么一段代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">*&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pic</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 640px;</span></span><br><span class="line"><span class="undefined">height: 1136px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#FFE872</span>;</span></span><br><span class="line"><span class="undefined">color: white;</span></span><br><span class="line"><span class="undefined">font-size: 150px;</span></span><br><span class="line"><span class="undefined">text-align: center;</span></span><br><span class="line"><span class="undefined">line-height: 1136px;</span></span><br><span class="line"><span class="undefined">font-family: cursive; </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span> Yellow <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Iphone5手机的分辨率为640x1136，我们在这个页面中用css画出了一个像素为640x1136的黄色方块，按照直觉在手机上应该满屏显示。但是实际效果不是这样，如下图。<img src="/images/mobile-adaptive/mobile-iPhone.png" alt="iphone5"><br>我们看到黄色方块没有预想的那样占满整个屏幕。原因是什么呢？<br>同时我们在浏览器模拟手机时，看到工具栏上方还显示这这样一个数据<img src="/images/mobile-adaptive/mobile-iPhone1.png" alt="iphone5"><br>为啥会显示320x568呢，还有DPR是什么？</p><h1 id="什么是DPR？"><a href="#什么是DPR？" class="headerlink" title="什么是DPR？"></a>什么是DPR？</h1><p>DPR的全程是设备像素缩放比(device PixelRatio)。<br>因为屏幕尺寸大小的相同的手机分辨率是不一样的，Iphone5的分辨率为640x1136，这就代表手机的屏幕上有640x1136个物理像素，但是屏幕尺寸320x568那么大，所以需要缩放以显示。<br>在这里640÷320=2，同时1136÷568=2，所以DPR=2，我们一般把DPR大于等于2的屏幕称为高清屏(retina屏)。 由此可知，同样像素大小的元素在iPhone5上会缩小一倍。</p><h2 id="进一步的疑问"><a href="#进一步的疑问" class="headerlink" title="进一步的疑问"></a>进一步的疑问</h2><p>我们解释了DPR是什么，但是还是会有疑惑，因为从理论上来说，即使这样，黄色方块也应该占满全部屏幕啊，不应该像图片那样，既不占满屏幕，也不是屏幕大小的1/2，更不是屏幕的2倍，这就很让人疑惑。<br>而这些呢，也牵扯到一段手机厂商的历史，在手机厂商制造手机时，考虑到自家手机可能会访问一些pc端的网页，为了有一个良好的页面体验，会默认将屏幕的宽度定为某一个默认值，然后在页面超出这个默认值的时候，又会自动缩放，让屏幕的宽度刚好可以适应整个网页。<br>在这里我们可以做个实验，如下图<img src="/images/mobile-adaptive/mobile-iPhone2.gif" alt="iphone5"><br>从这张图上我们可以看到元素宽度在980px的时候正好占满屏幕，所以iPhone5的默认宽度是980px，而当元素宽度大于980px的时候，从元素的高度可以看出屏幕明显将元素进行了缩放已达到完整显示的目的。</p><h1 id="如何控制浏览器缩放？"><a href="#如何控制浏览器缩放？" class="headerlink" title="如何控制浏览器缩放？"></a>如何控制浏览器缩放？</h1><p>可以说手机厂商自作聪明的作法(至少我是这么认为的)给很多前端开发者带来了麻烦，因为手机各自的分辨率不同，默认宽度不同，同样的页面在不同的手机上显示可能就会错位，如果用百分比做度量单位，就无法解决元素高度(高度的百分比是父元素的宽度的比例)还有边框宽度和元素定位等问题。<br>在这里我们可以通过meta标签的viewport来控制页面缩放。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=640"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">*&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pic</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 640px;</span></span><br><span class="line"><span class="undefined">height: 1136px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#FFE872</span>;</span></span><br><span class="line"><span class="undefined">color: white;</span></span><br><span class="line"><span class="undefined">font-size: 150px;</span></span><br><span class="line"><span class="undefined">text-align: center;</span></span><br><span class="line"><span class="undefined">line-height: 1136px;</span></span><br><span class="line"><span class="undefined">font-family: cursive; </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span> Yellow <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如图所示，我们在meta头设置了viewport的值为”width=640”，这样手机的默认宽度就定成了640px，元素正好覆盖了全部页面。<img src="/images/mobile-adaptive/mobile-iPhone3.png" alt="iphone5"><br>可是还有缺陷，就是浏览器还是会自动缩放。<br>这时候我们在meta表现中加入这行代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=640,maximum-scale=1, minimum-scale=1,initial-scale=1,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在这里scale的意思是缩放，maximum-scale和minimum-scale是最大缩放和最小缩放倍数，initial-scale为初始缩放倍数，user-scalable代表用户是否可以缩放。<br>此时页面效果变成了下面这样<img src="/images/mobile-adaptive/mobile-iPhone4.gif" alt="iphone5"><br>这是因为禁止了页面缩放，而iPhone5的屏幕像素大小只有320，所以页面是屏幕的2倍，且不可缩放。<br>如果还是需要达到我们之前满屏的目的，则需要改动viewport的width值和元素的宽度值。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=320,maximum-scale=1, minimum-scale=1,initial-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">*&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pic</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 320px;</span></span><br><span class="line"><span class="undefined">height: 568px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#FFE872</span>;</span></span><br><span class="line"><span class="undefined">color: white;</span></span><br><span class="line"><span class="undefined">font-size: 50px;</span></span><br><span class="line"><span class="undefined">text-align: center;</span></span><br><span class="line"><span class="undefined">line-height: 568px;</span></span><br><span class="line"><span class="undefined">font-family: cursive; </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span> Yellow <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样，页面就可以满屏显示了。</p><h2 id="不同手机下显示问题"><a href="#不同手机下显示问题" class="headerlink" title="不同手机下显示问题"></a>不同手机下显示问题</h2><p>通过测试我们发现，经过我们的设置黄色方块在不同的手机分辨率下保持了一样的大小，但是有一个小问题，那就是在不管页面内的元素的大小和多少的情况下，如果viewport的width设置一个固定的值，比如320，那么屏幕逻辑像素宽度小于320的手机总是可以左右滑动的，在一般情况下这些不符合我们的预期，所以我们需要给width设置一个特殊值<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样，页面的默认宽度就确定为手机逻辑像素宽度了。</p><h1 id="什么是rem"><a href="#什么是rem" class="headerlink" title="什么是rem"></a>什么是rem</h1><p>问题说到现在，似乎还没有解决，我们虽然搞定了手机的缩放问题，但是仍然无法做到让黄色方块在各个手机的分辨率下满屏显示，px在是个精确的度量单位，我们更需要一种按照手机分辨率，按比例缩放的单位！<br>而这就是rem存在的意义，rem与我们平常所见的em单位很像，实际上多出来的这个r就是response的意思<br>rem就是相对于页面根元素字体大小的度量单位，也就是说如果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么1rem = 16px，2rem = 2x16px，就是这么简单。<br>根据这个简单的特性，我们可以通过js先算出当前手机的宽度，然后通过一个事先约定好的比例公式算出的值给html的font-size赋值。这样rem的值就是一个响应式的值了<br>这样的代码有很多，在这里我给出一段参考代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">            resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">            recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">                <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">                docEl.style.fontSize = <span class="number">20</span> * (clientWidth / <span class="number">375</span>) + <span class="string">'px'</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p><p>这一段代码中是将iPhone6为底稿，所有的元素的像素宽度÷20，得到的值就是元素的rem值</p><h1 id="彻底解决问题"><a href="#彻底解决问题" class="headerlink" title="彻底解决问题"></a>彻底解决问题</h1><p>根据前面的知识点，我们来终结之前的满屏问题，因为上述代码是已iPhone6(375x667)为底稿的，所以如果要满屏的话，黄色方块的宽应该设置为375÷20=18.75rem，高设置为667÷20=33.35rem。<br>所以最终代码是这样的<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">*&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pic</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span>: 18<span class="selector-class">.75rem</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span>: 33<span class="selector-class">.35rem</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#FFE872</span>;</span></span><br><span class="line"><span class="undefined">color: white;</span></span><br><span class="line"><span class="undefined">font-size: 50px;</span></span><br><span class="line"><span class="undefined">text-align: center;</span></span><br><span class="line"><span class="undefined">line-height: 568px;</span></span><br><span class="line"><span class="undefined">font-family: cursive; </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span> Yellow <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">;(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> docEl = doc.documentElement,</span></span><br><span class="line"><span class="javascript">            resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span></span><br><span class="line"><span class="javascript">            recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">                docEl.style.fontSize = <span class="number">20</span> * (clientWidth / <span class="number">375</span>) + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="undefined">            &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>效果图如下<br><img src="/images/mobile-adaptive/mobile-iPhone5.gif" alt="iphone5"></p><h1 id="另一种办法——网易的移动端适配方案"><a href="#另一种办法——网易的移动端适配方案" class="headerlink" title="另一种办法——网易的移动端适配方案"></a>另一种办法——网易的移动端适配方案</h1><p>我们之前说过，如果给viewport的width设置一个固定值，则在不同分辨率下手机会进行自动缩放以适应屏幕，如果我们可以使用js计算出缩放比例，让手机屏幕正好是我们需要的固定值，然后在meta标签中加上计算出的缩放比例，这样是不是也能解决问题呢？<br>网易的metahandler.js就是这样实现的，只要在页面中引入js，并在js中结尾设置好需要的宽度<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用自适应屏幕的功能函数，位于182行</span></span><br><span class="line">opt.fixViewportWidth(<span class="number">640</span>);</span><br></pre></td></tr></table></figure></p><p>在页面加载的时候，js就能根据当前的手机智能的计算出缩放比例并加上<img src="/images/mobile-adaptive/mobile-iPhone6.gif" alt="iphone5"><br>这是一个不错的想法，但是在使用的过程中有几个小缺陷：</p><ul><li>指定宽度需要在js中修改，应该封装出接口供使用者使用，使用者需要自己修改封装一下</li><li>js没有监听屏幕变化的事件，在手机横屏的时候不能满屏</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>手机适配的方案有很多，大家可以选择合适自己的，有一些方案，如响应式也是不错的，关键需要看页面的布局和功能复杂度，大家理解了手机适配的原理，在以后可以更好的更快的构建适合自己的移动端网页。<br>另外我集合了一点方案在我的git上，欢迎大家star和关注<br><a href="https://github.com/zk-/mobile-response" target="_blank" rel="noopener">https://github.com/zk-/mobile-response</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从乔布斯推出智能手机以来，市面上已经有各种各样的牌子不同大小的智能手机，手机的分辨率也各有不同，同时移动互联网的发展，移动端网页技术也开始被人重视，初次接触移动端的同学曾经可能也和我一样迷茫过，在公司要求做一些移动端的网页时，没有足够的移动开发经验和基础知识，慌忙的在网上选择“阿里移动端适配方案”或者“网易移动端适配方案”，网页做完了，可是还是会迷惑为什么传统的网页在不同的手机上表现都如此不同，还有rem是什么，viewport又是什么？&lt;br&gt;今天就带大家梳理一下知识点，打好基础的同时选择适合自己的开发方案。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="移动端" scheme="http://www.jackfred.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>react分享与入门</title>
    <link href="http://www.jackfred.cn/2017/03/24/react-share/"/>
    <id>http://www.jackfred.cn/2017/03/24/react-share/</id>
    <published>2017-03-24T01:50:08.000Z</published>
    <updated>2019-11-21T01:35:50.636Z</updated>
    
    <content type="html"><![CDATA[<p>视频投稿在了b站，一共分了3p，有错误和遗漏欢迎大家弹幕指出<br><a id="more"></a><br><blockquote class="blockquote-center"><embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=9352249&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></blockquote></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视频投稿在了b站，一共分了3p，有错误和遗漏欢迎大家弹幕指出&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="react" scheme="http://www.jackfred.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>用js来做图像处理（二）</title>
    <link href="http://www.jackfred.cn/2017/02/22/images-2-canvas2/"/>
    <id>http://www.jackfred.cn/2017/02/22/images-2-canvas2/</id>
    <published>2017-02-22T00:55:00.000Z</published>
    <updated>2019-11-21T01:35:50.635Z</updated>
    
    <content type="html"><![CDATA[<p>高斯模糊是根据一个像素周围的像素的值通过复杂的计算获得一个与周围像素近似值的技术，如果只是简单的判断，那就是马赛克了。<br><a id="more"></a><br>资料参考：阮老师的<a href="http://blog.csdn.net/jiandanjinxin/article/details/51281828" target="_blank" rel="noopener">高斯模糊的算法</a></p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>读过阮老师的文章我们知道以下几点</p><ul><li>所谓”模糊”，可以理解成每一个像素都取周边像素的平均值。</li><li>“中间点”取”周围点”的平均值，就会失去细节。</li><li>取值范围越大，”模糊效果”越强烈。</li><li>正态分布显然是一种可取的权重分配模式。</li><li>利用状态发布的权重值可以算出中心点合适的加权平均值。</li><li>图像都是二维的，所以我们需要二维正态分布。</li><li>如果一个点处于边界，周边没有足够的点，就把已有的点拷贝到另一面的对应位置，模拟出完整的矩阵。</li></ul><p>矩阵函数如下：<br><img src="/images/images2canvas/canvas5.png" alt="canvas"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>有了理论和函数支持，做起来就比较容易了<br>我们先尝试做一个模糊半径为1像素的图。<br>在半径为1像素的情况下，中心点需要知道周围8个点的权重值，利用前面的函数，写出下面的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lisanzhi = <span class="number">0.9</span>;  <span class="comment">//离散值</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="number">1</span>;  <span class="comment">//设半径为1像素</span></span><br><span class="line"><span class="keyword">var</span> zhijing = <span class="number">2</span>*r + <span class="number">1</span>;  <span class="comment">//直径</span></span><br><span class="line"><span class="keyword">var</span> pointNums = zhijing*zhijing;  <span class="comment">//需要计算点的数量</span></span><br><span class="line"><span class="keyword">var</span> middleValue = <span class="built_in">Math</span>.ceil(pointNums/<span class="number">2</span>);  <span class="comment">//中值</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="number">1</span>/(<span class="number">2</span> * <span class="built_in">Math</span>.PI * lisanzhi * lisanzhi);  <span class="comment">//公式中一样的下半部分</span></span><br><span class="line"><span class="keyword">var</span> gaosiData = [];  <span class="comment">//存储结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pointNums; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="built_in">Math</span>.abs(i%zhijing - r);  <span class="comment">//获取对应值的x、y值</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">Math</span>.abs(r - <span class="built_in">parseInt</span>(i/zhijing));</span><br><span class="line">gaosiData[i] = <span class="built_in">Math</span>.pow(<span class="built_in">Math</span>.E , <span class="number">0</span> - (x*x + y*y)/(<span class="number">2</span> * lisanzhi * lisanzhi)) * temp;  <span class="comment">//套用公式计算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = gaosiData.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;  <span class="comment">//求和</span></span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;)</span><br><span class="line">gaosiData = gaosiData.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;  <span class="comment">//求权重</span></span><br><span class="line"><span class="keyword">return</span> item/sum;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>结果如下<br><img src="/images/images2canvas/canvas6.png" alt="canvas"><br>接下来就是求中心点周围的点在数组数据中的下标值，实现如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roundArray = [],  <span class="comment">//用来存放结果</span></span><br><span class="line">maxIndex = canvas.width * canvas.height * <span class="number">4</span>;  <span class="comment">//数组数据中最大下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; pointNums; k++) &#123;  <span class="comment">//根据下标和中心点的下标距离，求出真正下标</span></span><br><span class="line"><span class="keyword">var</span> juli = k - middleValue + <span class="number">1</span>,</span><br><span class="line">beishu = <span class="built_in">parseInt</span>(juli/zhijing),</span><br><span class="line">yushu = juli%zhijing;</span><br><span class="line">roundArray[k] = i + <span class="number">4</span>*(beishu*canvas.width+yushu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; roundArray.length; j++) &#123;  <span class="comment">//因为部分点在边缘，所以一些下标超过正常范围的就取对应点的下标</span></span><br><span class="line"><span class="keyword">if</span> (roundArray[j] &lt; <span class="number">0</span> || roundArray[j] &gt; maxIndex) &#123;</span><br><span class="line">roundArray[j] = roundArray[pointNums - <span class="number">1</span> - j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>做完这些，我们就可以根据前面两步的结果，计算最终中心点的值了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp=<span class="number">0</span>,temp1=<span class="number">0</span>,temp2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> m = <span class="number">0</span>; m &lt; pointNums; m++) &#123;  <span class="comment">//求和</span></span><br><span class="line">temp += imageDatas.data[roundArray[m]] * gaosiData[m];</span><br><span class="line">temp1 += imageDatas.data[roundArray[m]+<span class="number">1</span>] * gaosiData[m];</span><br><span class="line">temp2 += imageDatas.data[roundArray[m]+<span class="number">2</span>] * gaosiData[m];</span><br><span class="line">&#125;</span><br><span class="line">imageDatas.data[i] = temp;</span><br><span class="line">imageDatas.data[i+<span class="number">1</span>] = temp1;</span><br><span class="line">imageDatas.data[i+<span class="number">2</span>] = temp2;</span><br><span class="line">imageDatas.data[i+<span class="number">3</span>] = <span class="number">255</span>;</span><br></pre></td></tr></table></figure></p><p>效果图如下<br><img src="/images/images2canvas/canvas7.png" alt="canvas"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这一篇是在前面的文章基础上一步步推导过来的，高斯模糊本身不难，只要掌握原理即可很容易做到，本篇所写代码没有做性能优化，读者可以进一步开发，优化性能，功能解耦。<br>实验平台：<a href="https://codepen.io/jackfredzk/pen/egqBPG" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高斯模糊是根据一个像素周围的像素的值通过复杂的计算获得一个与周围像素近似值的技术，如果只是简单的判断，那就是马赛克了。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="canvas" scheme="http://www.jackfred.cn/tags/canvas/"/>
    
      <category term="高斯模糊" scheme="http://www.jackfred.cn/tags/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/"/>
    
      <category term="灰度处理" scheme="http://www.jackfred.cn/tags/%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/"/>
    
      <category term="反色" scheme="http://www.jackfred.cn/tags/%E5%8F%8D%E8%89%B2/"/>
    
      <category term="图像处理" scheme="http://www.jackfred.cn/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>用js来做图像处理（一）</title>
    <link href="http://www.jackfred.cn/2017/02/21/images-2-canvas/"/>
    <id>http://www.jackfred.cn/2017/02/21/images-2-canvas/</id>
    <published>2017-02-21T06:49:24.000Z</published>
    <updated>2019-11-21T01:35:50.635Z</updated>
    
    <content type="html"><![CDATA[<p>所有能被js实现的东西，最终都会以js的方式被实现<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>正如上面所说，昨天开始打算尝试能不能用js做一些图像处理的工作，直到现在，本人已经用js下的canvas实现了图像的灰度处理，反色，以及高斯模糊等功能。<br>资料参考：阮老师的<a href="http://blog.csdn.net/jiandanjinxin/article/details/51281828" target="_blank" rel="noopener">高斯模糊的算法</a></p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="导入图像"><a href="#导入图像" class="headerlink" title="导入图像"></a>导入图像</h2><p>canvas导入图像非常简单，使用canvas自带的drawImage函数即可导入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image;</span><br><span class="line">image.src = <span class="string">'./images/mm1.jpg'</span></span><br><span class="line">image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//在图像加载完成的时候导入</span></span><br><span class="line">ctx.drawImage(image,<span class="number">0</span>,<span class="number">0</span>)  <span class="comment">//后面的两个参数是导入图片的坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下，左图为原图，右图为canvas导入的图<br><img src="/images/images2canvas/canvas.png" alt="canvas"></p><h2 id="获取图像数据"><a href="#获取图像数据" class="headerlink" title="获取图像数据"></a>获取图像数据</h2><p>canvas在这里也为我们提供了简便的函数getImageData，用这个函数可以获取目标区域里图像的<strong>数组数据</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canvas.width = width;</span><br><span class="line">canvas.height = height;</span><br><span class="line">ctx.drawImage(image,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> imageDatas = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>,width,height);  <span class="comment">//参数意思是坐标已经x、y轴的偏移量</span></span><br><span class="line"><span class="built_in">console</span>.log(imageDatas)</span><br></pre></td></tr></table></figure></p><p>获取数据如图<br><img src="/images/images2canvas/canvas1.png" alt="canvas"></p><h2 id="重绘图像"><a href="#重绘图像" class="headerlink" title="重绘图像"></a>重绘图像</h2><p>上面我们拿到了图像数据，这时候假如我们处理好了，怎么用新数据重绘呢？<br>可以直接用canvas自带的putImageData函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.putImageData(imageDatas,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><h2 id="关于图像数据"><a href="#关于图像数据" class="headerlink" title="关于图像数据"></a>关于图像数据</h2><p>我们知道图像的每一个像素的颜色都有rgb三个颜色构成，canvas还增加了一种，就是透明度，所以在canvas中每一个像素都是有rgba值的。<br>对应到数组数据中，<strong>每四个数组元素表示一个像素的rgba值</strong>。<br>由此我们可以做个小练习，图像的第二排第一个像素的位置是 0 + 4 x (图像宽度 + 1)。<br><img src="/images/images2canvas/canvas2.png" alt="canvas"><br>基础只是已经了解的差不多了，现在开始简单的尝试</p><h1 id="灰度处理"><a href="#灰度处理" class="headerlink" title="灰度处理"></a>灰度处理</h1><p>把图像做灰度处理很简单，只要把每个像素的rgb三值做成一样的就可以了，因为每个像素的rgb的值不同，所以我们可以取平均值。代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imageDatas.data.length; i+=<span class="number">4</span>) &#123; <span class="comment">//每四个元素代表一个像素</span></span><br><span class="line"><span class="keyword">var</span> ddd = (imageDatas.data[i]+imageDatas.data[i+<span class="number">1</span>]+imageDatas.data[i+<span class="number">2</span>])/<span class="number">3</span>;</span><br><span class="line">imageDatas.data[i]=ddd;</span><br><span class="line">imageDatas.data[i+<span class="number">1</span>]=ddd;</span><br><span class="line">imageDatas.data[i+<span class="number">2</span>]=ddd;</span><br><span class="line">imageDatas.data[i+<span class="number">3</span>]=<span class="number">255</span>; <span class="comment">//透明度就最高即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下<br><img src="/images/images2canvas/canvas3.png" alt="canvas"></p><h1 id="反色"><a href="#反色" class="headerlink" title="反色"></a>反色</h1><p>反色的方法是取对应rgb中相反的值，即用255减去对应的值，结果为所求的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imageDatas.data.length; i+=<span class="number">4</span>) &#123; <span class="comment">//每四个元素代表一个像素</span></span><br><span class="line">imageDatas.data[i]=<span class="number">255</span>-imageDatas.data[i];</span><br><span class="line">imageDatas.data[i+<span class="number">1</span>]=<span class="number">255</span>-imageDatas.data[i+<span class="number">1</span>];</span><br><span class="line">imageDatas.data[i+<span class="number">2</span>]=<span class="number">255</span>-imageDatas.data[i+<span class="number">2</span>];</span><br><span class="line">imageDatas.data[i+<span class="number">3</span>]=<span class="number">255</span>; <span class="comment">//透明度就最高即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下<br><img src="/images/images2canvas/canvas4.png" alt="canvas"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>第一篇主要是介绍canvas下处理图像数据需要的一些基本知识，以及灰度处理和反色两个简单的图像处理技术，下一章会重点介绍如何对图像进行高斯模糊，以及高斯模糊的算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有能被js实现的东西，最终都会以js的方式被实现&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="canvas" scheme="http://www.jackfred.cn/tags/canvas/"/>
    
      <category term="高斯模糊" scheme="http://www.jackfred.cn/tags/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/"/>
    
      <category term="灰度处理" scheme="http://www.jackfred.cn/tags/%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/"/>
    
      <category term="反色" scheme="http://www.jackfred.cn/tags/%E5%8F%8D%E8%89%B2/"/>
    
      <category term="图像处理" scheme="http://www.jackfred.cn/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>用脚本锁住百度云下载加速倒计时,从而实现无限加速</title>
    <link href="http://www.jackfred.cn/2017/01/06/%E7%94%A8%E8%84%9A%E6%9C%AC%E9%94%81%E4%BD%8F%E7%99%BE%E5%BA%A6%E4%BA%91%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E5%80%92%E8%AE%A1%E6%97%B6-%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E5%8A%A0%E9%80%9F/"/>
    <id>http://www.jackfred.cn/2017/01/06/用脚本锁住百度云下载加速倒计时-从而实现无限加速/</id>
    <published>2017-01-06T01:03:36.000Z</published>
    <updated>2019-11-21T01:35:50.642Z</updated>
    
    <content type="html"><![CDATA[<p>百度云本来是会员可以加速，后来要超级会员才能加速，有点烦，最近手头又有一个大文件要下载，限速真心不爽，所以做了个小工具，现在简单说说原理。<br><a id="more"></a></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>如题，锁住百度云下载倒计时，实现无限时间加速</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://git.oschina.net/zk-/test/raw/master/LockTime.EXE" target="_blank" rel="noopener">点击这里下载</a></p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ul><li>运行百度云</li><li>打开小程序</li><li>下载文件，出现免费加速时，点击免费加速，然后按F2，即可锁住时间</li></ul><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>在我的win10 32位小本子上测试正常，其他平台没有机子做测试，有问题的同学可以评论告诉我<br>百度云版本为当前时间最新版本5.5.2，是否兼容老版本以及未来的新版本主要看百度云改不改逻辑了</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理很简单，百度云没有在服务器端对免费云加速时间做校验，所以本地修改逻辑就可以了</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>有两种方法可以实现<br>一种是找到控制时间变量的基址以及算出偏移量，把数值改大即可，但是考虑到如果百度云更新版本的话基址可能就会变掉，这样就失效了，所以不采用<br>还有一种是找到对时间变量做写操作的地址，注入脚本改写操作，让时间不减少就可以了，考虑到百度云近期不会对这一块有改动，如果做成工具，可以兼容多个版本<br>在小工具的使用体验上<br>一种是我直接把改好的小程序导出出来，做成一个修改版的百度云<br>还有一种是写成一个小工具，在用户需要时候使用<br>因为第一个是破坏式的方法，而第二个给了用户的选择权，使用完重启百度云，就会恢复正常，不影响其他使用，还可以兼容部分版本百度云，所以综合考虑用了第二个方案</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百度云本来是会员可以加速，后来要超级会员才能加速，有点烦，最近手头又有一个大文件要下载，限速真心不爽，所以做了个小工具，现在简单说说原理。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.jackfred.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="百度云" scheme="http://www.jackfred.cn/tags/%E7%99%BE%E5%BA%A6%E4%BA%91/"/>
    
      <category term="汇编" scheme="http://www.jackfred.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>impress简易教程</title>
    <link href="http://www.jackfred.cn/2016/12/23/impress%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <id>http://www.jackfred.cn/2016/12/23/impress简易教程/</id>
    <published>2016-12-23T02:26:37.000Z</published>
    <updated>2019-11-21T01:35:50.635Z</updated>
    
    <content type="html"><![CDATA[<p>快过年了，作为一个前端工程师，要写年终总结ppt啥的了，这里介绍一个炫酷的js框架，用网页实现比ppt还炫酷的效果。<br><a id="more"></a></p><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p><a href="https://juzoom.github.io/" target="_blank" rel="noopener">聚众编码！</a></p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>这里用的impress.js框架，这个框架帮你做到的是，把指定的div标签变成一个个独占整个页面的元素，通过给出的接口进行定位，是三维上的定位！然后通过js控制把每个元素转到当前窗口来，在浏览器支持css3的情况下使用css3的动画功能来实现的。</p><h1 id="项目地址和文档地址"><a href="#项目地址和文档地址" class="headerlink" title="项目地址和文档地址"></a>项目地址和文档地址</h1><p><a href="https://github.com/impress/impress.js" target="_blank" rel="noopener">项目地址</a><br><a href="https://github.com/impress/impress.js/blob/master/DOCUMENTATION.md" target="_blank" rel="noopener">文档地址</a></p><h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>首先要引入impress.js文件，和普通的js引入方式是一样的<br>然后在文档里加入代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"impress"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //id可以自定义</span><br></pre></td></tr></table></figure></p><p>然后在引入的impress文件下插入这段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">impress( <span class="string">"root"</span> ); <span class="comment">//这里是你的id，如果id是impress，则这一步省略</span></span><br><span class="line">impress().init();</span><br></pre></td></tr></table></figure></p><h1 id="插入ppt"><a href="#插入ppt" class="headerlink" title="插入ppt"></a>插入ppt</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在你指定的根div中间插入ppt类的div<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"impress"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"0"</span> <span class="attr">data-y</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">    test</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里div的class必须要有’step’，id可以有可以没有，如果没有，impress就会把你的id默认变成’step-1’这样的。<br>‘data-x’和’data-y’这样的就是ppt的定位</p><h2 id="2D平移"><a href="#2D平移" class="headerlink" title="2D平移"></a>2D平移</h2><p>如果我们再加入一段ppt类的div，页面就可以平移动起来了<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"impress"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test1"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"0"</span> <span class="attr">data-y</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">    test1</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test2"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"1600"</span> <span class="attr">data-y</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">    test2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>我们想加入缩放的话只要加入’data-scale’这个属性就可以了，赋值为数字，越大缩放越大<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"1600"</span> <span class="attr">data-y</span>=<span class="string">"0"</span> <span class="attr">data-scale</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">    test</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="2D旋转"><a href="#2D旋转" class="headerlink" title="2D旋转"></a>2D旋转</h2><p>如果想做旋转效果的ppt，加入’data-rotate’属性，赋值范围0~360<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"1600"</span> <span class="attr">data-y</span>=<span class="string">"0"</span> <span class="attr">data-rotate</span>=<span class="string">"90"</span> <span class="attr">data-scale</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">    test</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="3D定位"><a href="#3D定位" class="headerlink" title="3D定位"></a>3D定位</h2><p>加入’data-z’属性实现3D空间上的定位</p><h2 id="3D翻滚"><a href="#3D翻滚" class="headerlink" title="3D翻滚"></a>3D翻滚</h2><p>可能最炫酷的效果就是这个了，需要配合3D定位，属性有两个’data-rotate-x’和’data-rotate-y’，分别实现横向和纵向翻滚。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"step"</span> <span class="attr">data-x</span>=<span class="string">"6200"</span> <span class="attr">data-y</span>=<span class="string">"4300"</span> <span class="attr">data-z</span>=<span class="string">"-100"</span> <span class="attr">data-rotate-x</span>=<span class="string">"-40"</span> <span class="attr">data-rotate-y</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">    test</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="方法接口"><a href="#方法接口" class="headerlink" title="方法接口"></a>方法接口</h1><p>impress还给出了方法接口</p><h2 id="init"><a href="#init" class="headerlink" title=".init()"></a>.init()</h2><p>初始化用途<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> api = impress();</span><br><span class="line">api.init();</span><br></pre></td></tr></table></figure></p><h2 id="next"><a href="#next" class="headerlink" title=".next()"></a>.next()</h2><p>切换下一个ppt的功能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> api = impress();</span><br><span class="line">api.init();</span><br><span class="line">api.next(); <span class="comment">//使用方法下面都一样</span></span><br></pre></td></tr></table></figure></p><h2 id="prev"><a href="#prev" class="headerlink" title=".prev()"></a>.prev()</h2><p>切换前一个ppt的功能</p><h2 id="goto-stepIndex-stepElementId-stepElement-duration"><a href="#goto-stepIndex-stepElementId-stepElement-duration" class="headerlink" title=".goto( stepIndex | stepElementId | stepElement, [ duration ] )"></a>.goto( stepIndex | stepElementId | stepElement, [ duration ] )</h2><p>切换到指定ppt的功能，接受id和数字和dom元素，还能配置切换时间</p><h1 id="事件监听接口"><a href="#事件监听接口" class="headerlink" title="事件监听接口"></a>事件监听接口</h1><p>impress给出了两个事件监听接口<br>impress:stepenter 切入当前ppt的事件<br>impress:stepleave 切出当前ppt的事件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootElement = <span class="built_in">document</span>.getElementById( <span class="string">"impress"</span> );</span><br><span class="line">rootElement.addEventListener( <span class="string">"impress:stepenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> currentStep = <span class="built_in">document</span>.querySelector( <span class="string">".present"</span> );</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Entered the Step Element '"</span> + currentStep.id + <span class="string">"'"</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rootElement.addEventListener( <span class="string">"impress:stepleave"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> currentStep = event.target</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Left the Step Element '"</span> + currentStep.id + <span class="string">"'"</span> );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>impress还给出了一些样式特效，具体的读者自己去文档看吧！我就偷懒啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快过年了，作为一个前端工程师，要写年终总结ppt啥的了，这里介绍一个炫酷的js框架，用网页实现比ppt还炫酷的效果。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="impress" scheme="http://www.jackfred.cn/tags/impress/"/>
    
      <category term="js框架" scheme="http://www.jackfred.cn/tags/js%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>github以及github page访问缓慢的解决办法</title>
    <link href="http://www.jackfred.cn/2016/11/30/github%E4%BB%A5%E5%8F%8Agithub-page%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.jackfred.cn/2016/11/30/github以及github-page访问缓慢的解决办法/</id>
    <published>2016-11-30T07:30:53.000Z</published>
    <updated>2019-11-21T01:35:50.634Z</updated>
    
    <content type="html"><![CDATA[<p>如题，解决办法如下<br>修改hosts，加入这两行，其中zk-.github.io可以换成你的博客地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">151.101.100.133 zk-.github.io</span><br><span class="line">192.30.253.113 github.com</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如题，解决办法如下&lt;br&gt;修改hosts，加入这两行，其中zk-.github.io可以换成你的博客地址&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="工具" scheme="http://www.jackfred.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hosts" scheme="http://www.jackfred.cn/tags/hosts/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性初探</title>
    <link href="http://www.jackfred.cn/2016/11/30/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.jackfred.cn/2016/11/30/ES6新特性初探/</id>
    <published>2016-11-30T02:34:35.000Z</published>
    <updated>2019-11-21T01:35:50.634Z</updated>
    
    <content type="html"><![CDATA[<p>最近学的东西有点多，主要是最近从追求深度的一个坑里爬了出来，因为一无所获==！<br>这样下去就是浪费时间，所以把一些计划上学的东西学一遍，开始技能树乱加点模式。。<br><a id="more"></a><br>这次ES6新增了几个新特性，解决了平常使用js时需要处理一些麻烦的东西时的不便，增加了声明函数时使用箭头函数这种更<strong>清晰</strong>的语法模式（我是没觉得哪里好了，感觉更乱了==），还增加了一些牛逼的自定义迭代器这样的功能（嗯，越来越像python了），现在我就列举说明一下其中几个新特性及其用法。</p><h1 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h1><p>因为es6的语法每个浏览器支持的程度不一样，所以我们使用一种安全的方法来调试我们的脚本<br>首先安装es6转码器babel提供的命令行工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global babel-cli</span><br></pre></td></tr></table></figure></p><p>因为这款工具对于es6的语法支持的不是很全，我们需要安装官方提供的转码规则集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br></pre></td></tr></table></figure></p><p>然后在我们的项目下新建一个.babelrc文件并写入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">      <span class="string">"es2015"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: []</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这一步是为了让babel在执行的时候采用上面安装的规则集。<br>这些都搞完我们就可以开始学习了，在学习测试的时候可以用三种命令行方式验证我们的脚本<br>一个是 babel yourprogarm.js<br>这个可以直接在命令行输出翻译出来的脚本<br>一个是 babel-node yourprogarm.js (用node直接输出也可以)<br>这个可以直接运行你的脚本，输出结果<br>一个是 babel yourprogarm.js -o compiled.js<br>将你的脚本转成es5语法并保存到指定文件里面<br>大家各取所需</p><h1 id="块作用声明let以及常量声明const"><a href="#块作用声明let以及常量声明const" class="headerlink" title="块作用声明let以及常量声明const"></a>块作用声明let以及常量声明const</h1><p>废话不多说，直接先看代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//4</span></span><br></pre></td></tr></table></figure></p><p>我们都知道在这个例子里面，a虽然在if中声明了，但是if没有块级作用域，所以在外部也能正常访问a，这给初学者或多或少带来了理解困难，因为这是js语言的<strong>缺陷</strong>。在es6中，我们有了let这个块级声明，再也不用担心这类问题了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>另外我们在自己的程序中有时候希望声明一些常量，又不希望被别人更改，这时候就可以使用es6提供的const来声明变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">4</span>;</span><br><span class="line">a = <span class="number">5</span>;  <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><p>这些用法都非常简单易懂，但是要注意的是babel对这些特性的兼容是怎样实现的<br>在对于支持这些语法特性的浏览器来说，这些语法非常的安全，但是如果对于不支持这些语法特性的浏览器，babel需要翻译成浏览器支持的语法才能正常表现，现在我们就用babel命令来输出翻译后的代码是什么样的<br>拿第二段的代码举例，翻译后是这样的<br><img src="/images/es6/es6.png" alt="es6"><br>翻译的结果是babel在对应的变量前加了下划线，所以我们要注意的一点是在使用babel和es6的时候，不要出现相似变量名之间只差一个下划线的情况，这样就会出现难以调试和发现的bug</p><h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>英文名DESTRUCTURE（扔到有道翻译里面意思是“变性” ==！）<br>实际意思是一种新的赋值模式，叫解构<br>解构赋值提供了一种位赋值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b)  <span class="comment">//输出结果1 2</span></span><br></pre></td></tr></table></figure></p><p>大家看到了，就是对应位置的复制，这样以后如果需要交换变量值的时候就很方便，只需要一行代码就能实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure></p><p>解构赋值还提供了一种提取属性的赋值方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pt = &#123;<span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">444</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;x, y&#125; = pt;</span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// 123 444</span></span><br></pre></td></tr></table></figure></p><p>结果很明白，有的同学可能有疑问，如果我不想用xy这样和对象名属性一样的变量名怎么办，简单，在后面加上冒号就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pt = &#123;<span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">444</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:myvalue, y&#125; = pt;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 444</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(myvalue); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p><h1 id="字面量属性可计算"><a href="#字面量属性可计算" class="headerlink" title="字面量属性可计算"></a>字面量属性可计算</h1><p>这个特性很好理解，平常我们在一个对象中，读取或者写入一个动态生成的属性时，是这样做的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">'example'</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[b + <span class="string">'A'</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="string">'exampleA'</span>])  <span class="comment">//4</span></span><br></pre></td></tr></table></figure></p><p>在表达式中计算，现在es6加入的特性就是，在对象声明字面量的时候，就可以使用计算属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">[<span class="string">'example'</span> + <span class="string">'A'</span>]:<span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.exampleA)  <span class="comment">//6</span></span><br></pre></td></tr></table></figure></p><h1 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数 =&gt;"></a>箭头函数 =&gt;</h1><p>说实话这个玩意我开始用的时候真不习惯，感觉上可读性也没有多少提高，但是推出这个语法一定有他的用意，先说用法<br>一般函数声明是这样的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而es6的语法是这样的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个<strong>()</strong>就是声明参数的地方，剩下的就是函数解构体，其实箭头函数就是声明了一个匿名函数并复制给了abc，所以匿名函数的写法就是这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'123'</span>)&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><p>就是样子变了一下，如果说有什么要值得注意的话，就是箭头函数创建实名函数的时候，它是一个表达式，所以没有函数声明提前的说法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="REST-AND-SPREAD-延展运算符"><a href="#REST-AND-SPREAD-延展运算符" class="headerlink" title="REST AND SPREAD(延展运算符)"></a>REST AND SPREAD(延展运算符)</h1><p>上面说过es6把一些常见的其它语言的特性拿到了es6中来，这就是其中的一个<br>在函数中，我们的参数可以通过arguments来引用进来，如果一个函数要求的参数是2个，如果调用的时候传入了1个是不会报错的，只不过第二个参数默认会赋值undefined，如果传入了3个参数，也不会报错，多出来的那一个可以通过arguments[2]访问到。<br>可能是es6的专家们希望js能表现的和正常的语言一样吧，在es6中，参数可以这样写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">abc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">//1 2 3 4</span></span><br></pre></td></tr></table></figure></p><p>前面的三个点表示任意多的参数，我们还可以给参数赋默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = <span class="function">(<span class="params">a = <span class="number">6</span></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">abc()  <span class="comment">//6</span></span><br><span class="line">abc(<span class="number">4</span>)  <span class="comment">//4</span></span><br></pre></td></tr></table></figure></p><p>利用这些特性我们可以很方便的取到多余的参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = <span class="function">(<span class="params">a, b, ...args</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(a + b)</span><br><span class="line"><span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">abc(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//3 []</span></span><br><span class="line">abc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">//3 [3, 4]</span></span><br></pre></td></tr></table></figure></p><h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>说模版实际上es6给定义的模版功能比较弱，模版文本用 <strong>`</strong> 围起来，这个标点就是键盘左上方esc键下面的那个键，动态的文本内容用 <strong>${}</strong> 表示，所以基本用法如下所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'zk'</span>;</span><br><span class="line"><span class="keyword">var</span> templateString = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, and I know 1 + 1 = <span class="subst">$&#123;<span class="number">1</span> + <span class="number">1</span>&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(templateString)  <span class="comment">//my name is zk, and I know 1 + 1 = 2</span></span><br></pre></td></tr></table></figure></p><p>在${}中我们可以放入变量也可以放入表达式，但是 templateString 在定义的时候就已经被计算出字符串并赋值给了它，所以templateString这样的变量在生成的时候就只能是固定的字符串格式。</p><h1 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h1><p><strong>ladys and 乡亲们，你们盼望已久的面向对象终于来啦！</strong><br><strong>ladys and 乡亲们，你们盼望已久的面向对象终于来啦！</strong><br><strong>ladys and 乡亲们，你们盼望已久的面向对象终于来啦！</strong><br>js面向对象编程说了辣么多年，网上的相关文章也是辣么多，现在终于出来了，刚刚看到的时候说实话我是很激动的，但是研究了一下，发现因为js的历史原因，实际上，es6对于面向对象的特性实现只是我们在写代码的时候感觉像是那么回事，实际上还是构造器以及原型链，继承方式也是这两种<br><img src="/images/emotions/trxc.jpg" alt="突然消沉"><br>不管了，最起码写写代码的体验上提升了很多。</p><blockquote><p>有对js对象继承不太理解的同学，可以看看这篇我的文章<strong><a href="https://zk-.github.io/2016/10/26/js继承的方式和意义/" target="_blank" rel="noopener">js继承的方式和意义</a></strong></p></blockquote><p>上代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name)&#123;<span class="comment">//这是构造器</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">sayHello()&#123;<span class="comment">//这是原型方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent(<span class="string">'parent'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(parent.name)  <span class="comment">//parent</span></span><br><span class="line">parent.sayHello()  <span class="comment">//my name is parent</span></span><br></pre></td></tr></table></figure></p><p>继承的写法也很容易，用关键词extends，父类用super表示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name)&#123;<span class="comment">//这是构造器</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">sayHello()&#123;<span class="comment">//这是原型方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'my name is '</span> + <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name, sex)&#123;</span><br><span class="line"><span class="keyword">super</span>(name);  <span class="comment">//构造器继承</span></span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">sayHello()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'i am a child,'</span> + <span class="keyword">super</span>.sayHello())  <span class="comment">//原型链继承</span></span><br><span class="line">&#125;</span><br><span class="line">saySex()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'baby'</span>,<span class="string">'male'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.name)  <span class="comment">//baby</span></span><br><span class="line"><span class="built_in">console</span>.log(child.sex)  <span class="comment">//male</span></span><br><span class="line">child.sayHello()  <span class="comment">//i am a child,my name is baby</span></span><br><span class="line">child.saySex()  <span class="comment">//male</span></span><br></pre></td></tr></table></figure></p><h1 id="模块module"><a href="#模块module" class="headerlink" title="模块module"></a>模块module</h1><p>模块加载在es6中得到了原生支持<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Message.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> message = <span class="string">'Hello Babel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;message&#125; <span class="keyword">from</span> <span class="string">'./Message'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// Hello Babel</span></span><br></pre></td></tr></table></figure></p><p>导出可以实名导出也可以默认导出<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Message.js</span></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Babel'</span>;</span><br><span class="line"><span class="keyword">const</span> version = <span class="string">'v5.0'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">  greeting: greeting,</span><br><span class="line">  name: name,</span><br><span class="line">  version: version</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message.js</span></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Babel'</span>;</span><br><span class="line"><span class="keyword">const</span> version = <span class="string">'v5.0'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  greeting: greeting,</span><br><span class="line">  name: name,</span><br><span class="line">  version: version</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;greeting, name, version&#125; <span class="keyword">from</span> <span class="string">'./Message'</span>;</span><br></pre></td></tr></table></figure></p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>这是一个大内容，下一篇开始说这个概念吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学的东西有点多，主要是最近从追求深度的一个坑里爬了出来，因为一无所获==！&lt;br&gt;这样下去就是浪费时间，所以把一些计划上学的东西学一遍，开始技能树乱加点模式。。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="ES6" scheme="http://www.jackfred.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解微信小程序</title>
    <link href="http://www.jackfred.cn/2016/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.jackfred.cn/2016/11/22/深入理解微信小程序/</id>
    <published>2016-11-22T15:00:30.000Z</published>
    <updated>2019-11-21T01:35:50.642Z</updated>
    
    <content type="html"><![CDATA[<p>一个月前微信小程序火爆朋友圈，当时我对这个并不是很感兴趣，现在公司需要开发这个，花了一天的时间，把微信的文档看了个大概，看到了很多技术和工具的影子，其实微信小程序不是什么新鲜的东西，都是我们平常学习过的东西。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>微信小程序可以通过微信获取到两个方面信息和权限，一个是手机使用者的手机信息和权限，一个是获取其微信用户的信息。而第一个是安装微信时获取到的权限，小程序就是通过调用微信的接口获取手机信息和权限，而第二个则是微信自带的功能。所以小程序对于微信来说，就像插件对于chrome浏览器一样，从配置上，这二者也有异曲同工之处。<br>小程序与插件相比，其创新程度在于两点：小程序的页面核心是一个响应的数据绑定系统，视图层WXML文件是一种类似xml语法的文件，主要承载页面的渲染显示，逻辑层js文件为视图层主要提供数据和行为。小程序的第二个创新之处在于为小程序以及其页面提供了生命周期函数，当用户加载小程序，退出小程序，加载页面销毁页面时都会有对应的生命周期函数可以贡开发者使用。<br>下面就开始说一说小程序的基本内容</p><h1 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h1><p>微信小程序的文档写得非常的完美，主要从结构、页面组件、权限接口三个方面诠释了小程序的主要内容，其文档地址大家可以点击<strong><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/MINA.html?t=20161122" target="_blank" rel="noopener">这里</a></strong>访问。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>首先看一眼一个基础小程序的目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">E:\TEST</span><br><span class="line">│  app.js  //入口函数，程序生命周期函数声明的地方</span><br><span class="line">│  app.json  //全局配置，程序声明获取权限的地方</span><br><span class="line">│  app.wxss  //全局样式，程序定义公共样式的地方</span><br><span class="line">│</span><br><span class="line">├─pages</span><br><span class="line">│  ├─index</span><br><span class="line">│  │      index.js</span><br><span class="line">│  │      index.wxml</span><br><span class="line">│  │      index.wxss</span><br><span class="line">│  │</span><br><span class="line">│  └─logs</span><br><span class="line">│          logs.js  //逻辑层代码，包含小程序数据和行为</span><br><span class="line">│          logs.json  //小程序声明获取权限的地方，只能获取部分权限(window)，向上覆盖全局配置</span><br><span class="line">│          logs.wxml  //视图层，小程序页面承载内容的地方</span><br><span class="line">│          logs.wxss  //小程序页面样式，向上覆盖</span><br><span class="line">│</span><br><span class="line">└─utils</span><br><span class="line">        util.js  //自定义公共函数，文件夹和文件的名字随意</span><br></pre></td></tr></table></figure></p><p>一个小程序的整个目录结构差不多就是这样，根目录下的app.js为小程序的入口函数，页面的声明通过app.json来实现，小程序要获取用户的各种信息和权限需要通过这里声明，同时小页面包含的所有页面也需要在这里声明。<br>小程序目录结构的第二个重点是页面下的文件，一般页面下需要包含.js .json .wxml .wxss这四类文件，文件名与文件夹名同名，相关功能已经在注释中说明，不在赘述。<br><strong>可以看到小程序的文件结构非常的简单，我们学习它也很容易</strong></p><h1 id="权限获取"><a href="#权限获取" class="headerlink" title="权限获取"></a>权限获取</h1><p>权限获取分两个方面，一个是根目录下app.json的权限获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性类型必填描述</span><br><span class="line">pagesString Array是设置页面路径</span><br><span class="line">windowObject否设置默认页面的窗口表现</span><br><span class="line">tabBarObject否设置底部 tab 的表现</span><br><span class="line">networkTimeoutObject否设置网络超时时间</span><br><span class="line">debugBoolean否设置是否开启 debug 模式</span><br></pre></td></tr></table></figure></p><p>其中window是定义小程序页面的默认设置，如果页面中没有json配置文件或者json配置文件声明的没有覆盖声明对应的权限，则使用默认app.json下的配置，页面下的json文件只能覆盖window属性的权限。</p><h1 id="视图层组件"><a href="#视图层组件" class="headerlink" title="视图层组件"></a>视图层组件</h1><p>小程序的页面wxml文件使用的是一个类似xml语法的文件，每一个标签都有其对应的闭合标签(templete标签和import标签和include标签除外)，全部都是小写。<br>例如&lt;image&gt;必须有对应的&lt;/image&gt;，而且大小写敏感，写成&lt;/Image&gt;是不可以的。<br>页面标签我总结了一下从功能上可以分为三类<br>第一类是普通的视图容器view和block，这两类都是识图容器一类，在页面中主要作用是分割页面内容，并且和其他标签一样，可以承载数据和渲染逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// pages/test/test.wxml</span><br><span class="line">&lt;view&gt;&#123;&#123;testData&#125;&#125;&lt;/view&gt;  //直接使用在js的data下声明的数据</span><br><span class="line"></span><br><span class="line">// pages/test/test.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    testData:&apos;hello world!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  ···省略</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>效果图<br><img src="/images/weixinxiaochenxu/weixinxiaochenxu1.png" alt="微信小程序"><br>承载行为注意通过bindtap或者catchtap来实现，这两种区别稍后在说明，现在用bindtap举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// pages/test/test.wxml</span><br><span class="line">&lt;view bindtap=&quot;testtap&quot;&gt;&#123;&#123;testData&#125;&#125;&lt;/view&gt;  //绑定testtap函数</span><br><span class="line"></span><br><span class="line">// pages/test/test.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    testData:&apos;hello world!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  testtap:function(event)&#123;  //点击时执行的函数</span><br><span class="line">    wx.showToast(&#123;</span><br><span class="line">      title: &apos;hello world&apos;,</span><br><span class="line">      icon: &apos;success&apos;,</span><br><span class="line">      duration: 2000</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  ···</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>效果图<br><img src="/images/weixinxiaochenxu/weixinxiaochenxu2.gif" alt="微信小程序"></p><p>第二类则是小程序内置的标签，这些标签功能多而且强大，下面就拿标签picker举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// pages/test/test.wxml</span><br><span class="line">&lt;picker bindchange=&quot;bindPickerChange&quot; value=&quot;1&quot; range=&quot;&#123;&#123;pickerData&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;picker&quot;&gt;</span><br><span class="line">        选择</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/picker&gt;</span><br><span class="line"></span><br><span class="line">// pages/test/test.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    testData:&apos;hello world!&apos;,</span><br><span class="line">    pickerData:[1,2,3]</span><br><span class="line">  &#125;,</span><br><span class="line">  bindPickerChange: function(event)&#123;</span><br><span class="line">    console.log(&apos;test&apos;)</span><br><span class="line">  &#125;···</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>效果图<br><img src="/images/weixinxiaochenxu/weixinxiaochenxu3.gif" alt="微信小程序"></p><p>第三类则是模版标签，即templete标签，为了便于管理，我们需要在根目录下新建一个templete文件夹，在文件夹内新建我们的模版文件，文件名自定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// templete/test.wxml</span><br><span class="line">&lt;template name=&quot;test&quot;&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;number&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>我们需要为标签添加一个name属性(在所有的模版文件中，name属性最好不一样)，里面写好我们所需要的内容，在需要使用模版的文件中使用import来引入，文件中通过is属性来使用，data属性来填入数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// pages/test/test.wxml</span><br><span class="line">&lt;import src=&quot;../templete/test.wxml&quot;/&gt;</span><br><span class="line">&lt;template is=&quot;test&quot; data=&quot;&#123;&#123;number: &apos;1&apos;&#125;&#125;&quot;/&gt;</span><br><span class="line">&lt;template is=&quot;test&quot; data=&quot;&#123;&#123;number: &apos;2&apos;&#125;&#125;&quot;/&gt;</span><br><span class="line">&lt;template is=&quot;test&quot; data=&quot;&#123;&#123;number: &apos;3&apos;&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>效果图<br><img src="/images/weixinxiaochenxu/weixinxiaochenxu4.png" alt="微信小程序"><br><strong>是不是感觉似曾相识？没错，开发过vue的同学有福了，其实小程序页面的开发逻辑和vue有很多相似的地方</strong></p><h1 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h1><p>逻辑层开发需要先注册，注册有程序注册，即在app.js里面用App()方法，还有页面注册，即在页面文件js中用Page()方法。<br>每个页面都有独立的作用域，小程序提供getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈，getCurrentPages只能在页面中使用，getApp哪里都能用，主要用来设置和读取全局变量</p><h2 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h2><p>程序通过app.js来注册，提供三个周期函数，onLunch当初始化完成启动小程序的时候，onShow当小程序从后台进入页面的时候，onHide从前台进入后台的时候。开发者可以在App()中定义其他的属性和方法，作为全局作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  onLaunch: function() &#123;</span><br><span class="line">    // Do something initial when launch.</span><br><span class="line">  &#125;,</span><br><span class="line">  onShow: function() &#123;</span><br><span class="line">      // Do something when show.</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide: function() &#123;</span><br><span class="line">      // Do something when hide.</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData: &apos;I am global data&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h2><p>页面通过在app.json下指定的文件名的js文件来注册，提供一个默认属性和七个周期函数，默认属性data，为页面提供初始化数据，wxml渲染页面时提供数据。<br>onLoad为生命周期函数，页面加载是触发<br>onReady为生命周期函数，页面初次渲染完成时触发<br>onShow为生命周期函数，监听页面显示时触发<br>onHide为生命周期函数，监听页面隐藏时触发<br>onUnload为生命周期函数，监听页面卸载(关闭这个页面或者重定向页面时候触发)<br>onPullDownRefresh为页面相关事件处理函数，用户下拉动作时触发<br>onReachBottom为页面相关事件处理函数，页面上拉触底时触发<br>补一张官方给出的页面生命周期图<br><img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/mina-lifecycle.png?t=20161122" alt="微信小程序"></p><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>样式在前面有提及过，这里要特别指出的是，小程序的样式文件wxss具有大部分css的特性，在尺寸单位上小程序扩展了两个单位<br>一个是rpx，可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素<br>一个是rem，规定屏幕宽度为20rem；1rem = (750/20)rpx 。<br>在样式导入上，支持css的内联样式，样式文件与识图文件名相同默认导入进去，在样式文件中可以使用<strong>@import “common.wxss”</strong>导入其他文件，app.wcss默认给所有页面导入进去。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在小程序中，因为是在JsCore中运行，所以不存在window或者globle这样的对象，所以很多js库不能直接引入进去，只要里面使用了window这样的对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>小程序的开发思路和chrome插件的开发思路有很多相似之处，页面的构建和vue很相似，目前来说小程序没有引入更多复杂的概念，文章剩下没有讲过的东西大多数都是一些api函数，需要时查一下调用一下即可，总体感觉文章说的有一点混乱，读者有意见可以在下面提出，我会及时修正，以后我也会优化这篇文章，在不久我还会出第二篇小程序的实践文章，点击文章下面的微信小程序标签就可以看到所有有关微信小程序的文章，或者订阅rss也可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个月前微信小程序火爆朋友圈，当时我对这个并不是很感兴趣，现在公司需要开发这个，花了一天的时间，把微信的文档看了个大概，看到了很多技术和工具的影子，其实微信小程序不是什么新鲜的东西，都是我们平常学习过的东西。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="微信小程序" scheme="http://www.jackfred.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>js继承的方式和意义</title>
    <link href="http://www.jackfred.cn/2016/10/26/js%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E6%84%8F%E4%B9%89/"/>
    <id>http://www.jackfred.cn/2016/10/26/js继承的方式和意义/</id>
    <published>2016-10-26T11:01:29.000Z</published>
    <updated>2019-11-21T01:35:50.635Z</updated>
    
    <content type="html"><![CDATA[<p>在写这篇博客的时候，我就做好了撕逼的准备<br><a id="more"></a><br>js是一个无类语言，在日常编码中，我们可能需要js来创建一些类似面向对象里面“类”的东西，来实现代码复用。<br>js是一个基于对象的语言，没有类的概念，但是我们可以通过一些办法来模拟实现类的功能。<br>在写这篇博客的时候，我先在百度上搜了一下，网上说js的继承有五种办法</p><blockquote><p>1.使用对象冒充实现继承<br>2.采用call方法改变函数上下文实现继承<br>3.采用Apply方法改变函数上下文实现继承<br>4.采用原型链的方式实现继承<br>5.采用混合模式实现继承</p></blockquote><p>具体的文章大家可以自己百度一下，这样的文章网上很多，而且长得都一样。<br>但是我对此有一点不同的看法，js模拟实现类功能从实现的意义上来说最多只有3种，即<br>1.原型链继承<br>2.构造器继承<br>3.原型链和构造器混用继承</p><p>让我们一点点深入，来慢慢了解，为什么我说只有三种方法</p><h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><p>原型链的概念其实不难理解，就是一种类似于职责链一样模式的模式，什么是职责链呢？<br>举个例子，我们去银行取钱，如果我们只是取几百块前，最快最好的办法是直接去ATM机取钱<br>如果我们要取几十万，就必须要去柜台，让银行的工作人员帮你取钱<br>如果我们要是取几个亿 ==！ 银行人员一定非常的紧张，告诉你过几天再来，柜台上没有那么多钱，然后再把事情报告给当地行长，等到前到位的时候通知取钱<br>咳咳，如果我们想和银行谈一个价值几百个亿的合作♂ 这件事都不是ATM机、银行工作人员、当地行长能接手的事，他们就需要把这件事上报到总部，让总部的人过来和我们来谈合作的事<br>在这个实例中，我们能看到的就是职责链模式，就是<br>消费者产生一个需求的时候，生产者接手这个需求，如果不能处理它，就往上传递，直到有一个生产者能够处理它</p><p>原型链就是一样的结构，js内置了许多对象，所有的对象，除了字符串、数字、布尔值、null和undefined以外，他们的原型链的终点都是Object</p><blockquote><p>这句话不是很准确，字符串、数字和布尔值是一种不可变的对象，但是最终点也是Object<br>Object的原型链是null</p></blockquote><p><img src="/images/yuanxinglian/yuanxinglian1.png" alt="原型链"><br>原型链呢就是一个对象，你调用他的方法，比如对象A，你调用A.sayName()，如果A有sayName这个方法，则直接调用，如果没有，则通过A是原型链向上查找，如果原型链上有这个方法，则调用，没有就继续查找，如果找不到，则会返回一个Uncaught TypeError错误或者undefined。<br>如果对象和原型链上都有这个方法，则现有的方法会覆盖原型链上的方法。<br>举个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Parent.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello parent'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child;</span><br><span class="line">child.sayHello()<span class="comment">//输出hello parent</span></span><br></pre></td></tr></table></figure></p><p>我们看到child调用sayHello成功了，调用的是Parent的方法，我们再看一下覆盖的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Parent.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello parent'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent;</span><br><span class="line">Child.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello child'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child;</span><br><span class="line">child.sayHello()<span class="comment">//输出hello child</span></span><br><span class="line">child.constructor.prototype.sayHello()<span class="comment">//输出hello parent</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到child的sayHello覆盖了parent的方法，但是我们可以通过访问constructor看到实际上这个方法还存在的。</p><h1 id="构造器继承"><a href="#构造器继承" class="headerlink" title="构造器继承"></a>构造器继承</h1><p>js函数可以被当作构造器使用，通过返回的对象完成构造<br>如果没有指定返回一个对象，默认返回的是this<br>举个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent</span><br><span class="line"><span class="built_in">console</span>.log(parent.name)<span class="comment">//输出parent</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherParent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'hahaha'</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherparent = <span class="keyword">new</span> AnotherParent;</span><br><span class="line"><span class="built_in">console</span>.log(anotherparent.name) <span class="comment">//输出hahaha</span></span><br></pre></td></tr></table></figure></p><p>而所谓构造器继承，就是把需要继承的对象在构造过程中，调用被继承的对象的构造方法来处理这个继承对象需要构造的目标<br>让我们来实现一个构造器继承<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> parent = Parent.bind(<span class="keyword">this</span>); <span class="comment">//将执行环境绑定到Child来</span></span><br><span class="line">parent();</span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child;</span><br><span class="line"><span class="built_in">console</span>.log(child.name) <span class="comment">//输出parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child.age) <span class="comment">//输出10</span></span><br></pre></td></tr></table></figure></p><p>是不是很简单？其实这一段的代码和下面这段代码是一样的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child;</span><br><span class="line"><span class="built_in">console</span>.log(child.name)</span><br><span class="line"><span class="built_in">console</span>.log(child.age)</span><br></pre></td></tr></table></figure></p><p>这就是构造器继承，实际上这个方法和上面提到的网上的方法的123方法是同一种，换汤不换药，原理都是通过构造器实现继承<br>可以看看网上给的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用对象冒充实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">firstname</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.fname=firstname;  </span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">40</span>;  </span><br><span class="line">    <span class="keyword">this</span>.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">firstname</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.parent=Parent;  </span><br><span class="line">    <span class="keyword">this</span>.parent(firstname);  <span class="comment">//实际上这一段的意义就是将执行环境上下文改变了,和上面的例子一样</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.parent;  </span><br><span class="line">    <span class="keyword">this</span>.saySomeThing=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.fname);  </span><br><span class="line">        <span class="keyword">this</span>.sayAge();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> mychild=<span class="keyword">new</span> Child(<span class="string">"李"</span>);  </span><br><span class="line">mychild.saySomeThing();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.采用call方法改变函数上下文实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">firstname</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.fname=firstname;  </span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">40</span>;  </span><br><span class="line">    <span class="keyword">this</span>.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">firstname</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.saySomeThing=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.fname);  </span><br><span class="line">        <span class="keyword">this</span>.sayAge();  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> firstname;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> child=<span class="keyword">new</span> Child(<span class="string">"张"</span>);  </span><br><span class="line">Parent.call(child,child.getName());  <span class="comment">// call只是借用罢了,作用的对象还是child,原理还是构造器继承</span></span><br><span class="line">child.saySomeThing(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.采用Apply方法改变函数上下文实现继承 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">firstname</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.fname=firstname;  </span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">40</span>;  </span><br><span class="line">    <span class="keyword">this</span>.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">firstname</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.saySomeThing=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.fname);  </span><br><span class="line">        <span class="keyword">this</span>.sayAge();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> firstname;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> child=<span class="keyword">new</span> Child(<span class="string">"张"</span>);  </span><br><span class="line">Parent.apply(child,[child.getName()]);  <span class="comment">//???换个函数就能算一种了???</span></span><br><span class="line">child.saySomeThing();</span><br></pre></td></tr></table></figure></p><p>我们可以看到网上说的这三种其实是一种，都是构造器继承，只是表现的手法不一样，不能算三种<br>（如果有读者对我的观点有什么不同的意见，欢迎在下面评论提出来）</p><h1 id="关于混合继承的吐槽"><a href="#关于混合继承的吐槽" class="headerlink" title="关于混合继承的吐槽"></a>关于混合继承的吐槽</h1><p>如果按照我刚才的逻辑，混合继承应该也不算一种继承方式，这点我承认，但是我还是把它拿出来了算作一种，原因很简单，就是因为它的使用场景和其他两种都不一样，而上面那三种的基本就是一样的，至于都有哪些不一样，请往下看。</p><h1 id="意义以及优缺点"><a href="#意义以及优缺点" class="headerlink" title="意义以及优缺点"></a>意义以及优缺点</h1><p>先说结论，原型链继承中的原型对象是共享的，构造器构造出来的对象是独立的</p><h2 id="原型链继承的意义以及优缺点"><a href="#原型链继承的意义以及优缺点" class="headerlink" title="原型链继承的意义以及优缺点"></a>原型链继承的意义以及优缺点</h2><p>我们来看这样的一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Parent.prototype = &#123;</span><br><span class="line">testArray:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child;</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child;</span><br><span class="line"></span><br><span class="line">child1.testArray.push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.testArray) <span class="comment">//输出[1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.testArray) <span class="comment">//输出[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到child1对象的操作影响到了child2对象，原因很简单，他们用的原型对象是相同的共享的，意思就是原型对象指向的地址是一样的，任何对Parent原型的更改，都会反应到继承他的子对象中<br>所以在原型中是不适合写属性进去的，除非你有意把这样的功能设计进去。<br>同时，如果判断一下<br><img src="/images/yuanxinglian/yuanxinglian2.png" alt="原型链"><br>结果发现child1属于Parent和Child，如果在复杂场景中，我们还需要找有没有别的对象继承了Child，这样才能确定一个对象是属于哪个构造器的，无疑非常的麻烦，这也是原型链的缺点</p><h2 id="构造器继承的意义以及优缺点"><a href="#构造器继承的意义以及优缺点" class="headerlink" title="构造器继承的意义以及优缺点"></a>构造器继承的意义以及优缺点</h2><p>继续看一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.testArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> parent = Parent.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child;</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child;</span><br><span class="line"></span><br><span class="line">child1.testArray.push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.testArray) <span class="comment">//输出[1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.testArray) <span class="comment">//输出[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p><p>和原型链不同的是，构造器的继承都是独立的互不影响<br>查看一下类型<br><img src="/images/yuanxinglian/yuanxinglian3.png" alt="原型链"><br>很准确的判断出来了类型</p><h2 id="混合继承的意义以及优缺点"><a href="#混合继承的意义以及优缺点" class="headerlink" title="混合继承的意义以及优缺点"></a>混合继承的意义以及优缺点</h2><p>混合继承适用与复杂的应用场景，当需要一些对象共享一些基础的静态方法，原型链有效的减少了重复的代码，而且还能实现多态，如果子对象需要生成独立互不影响的内部对象，构造器则能够很好的维护好子对象中的内部对象而不影响其它对象<br>原型链因为他的特殊性，还可以用原来进行共享对象的数据交换<br>好处有很多，但是在实际生产环境中，为了便于代码的可读性以及可维护性，如果不是必须的话，最好使用一种来实现</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写这篇博客的时候，我就做好了撕逼的准备&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="js" scheme="http://www.jackfred.cn/tags/js/"/>
    
      <category term="继承" scheme="http://www.jackfred.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="http://www.jackfred.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:单例模式</title>
    <link href="http://www.jackfred.cn/2016/10/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.jackfred.cn/2016/10/24/读书笔记-单例模式/</id>
    <published>2016-10-24T07:34:26.000Z</published>
    <updated>2019-11-21T01:35:50.643Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是设计模式里面最简单的一种模式，但是用处非常的广泛，用好了可以小幅度的提示整个页面的性能。<br><a id="more"></a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。</p><h1 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h1><p>用闭包实现创建对象并抛出引用，以后在调用时直接抛出引用，不再创建</p><h1 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createH1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> flag;<span class="comment">//上一层的执行环境,变量没有办法被自动消除,因为下一层的函数引用的它</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;<span class="comment">//判断是否有值,如果有,就返回对该值的引用</span></span><br><span class="line"><span class="keyword">return</span> flag</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">flag = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>);</span><br><span class="line">flag.innerHTML = <span class="string">'test'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>createH1 在一开始使用了一个闭包，创建了一个只能它自己访问的值flag，然后在判断flag是否有值，如果有值，则直接返回flag的引用，如果没有则做创建操作，并给flag赋值，这样就可以保证在调用createH1这个函数时，创建操作只做了一遍，而剩下的执行都是返回引用。<br>测试结果<br><img src="/images/moshi/moshi1.jpg" alt="单例模式"><br>在js中单例模式并不是一个复杂的东西，但是能给我们日常工作带来好处，比如缓存。</p><h1 id="实战题"><a href="#实战题" class="headerlink" title="实战题"></a>实战题</h1><p>这是一个来自<a href="https://www.codewars.com" target="_blank" rel="noopener">codewars</a>的题目</p><blockquote><p>Description:<br>Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.<br>You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?<br>The parameter of the function findNb (find_nb, find-nb) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + … + 1^3 = m if such a n exists or -1 if there is no such n.<br>Examples:<br>findNb(1071225) –&gt; 45<br>findNb(91716553919377) –&gt; -1</p></blockquote><p>大意就是给出一个很大的数字,找到他的”基数”。即给出一个数m，存在一个数n，使得m = n^3 + (n-1)^3 + … + 1^3 如果存在这个数就返回这个数,如果不存在则返回-1<br>这道题呢用电脑实现虽然麻烦了一点，但是也不难，直接给出正常解题答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jisuan = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = num;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        sum = sum + i*i*i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findNb</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(jisuan(i)==m)&#123;</span><br><span class="line">            result = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(jisuan(i)&gt;m)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样子写没什么问题，但是有一个缺点，就是如果要执行计算多个数据的话，计算机就会在每次计算都会从1开始递增计算，这无疑增加了没必要的计算时间，我们可以创建一个缓存，在不污染全局变量的情况下，把结果缓存起来，下次再执行的时候，直接查找结果并返回<br>重新构建的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jisuan = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = num;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        sum = sum + i*i*i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getResult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache[num])&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[num]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[num] = jisuan(num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findNb</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(getResult(i)==m)&#123;</span><br><span class="line">            result = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getResult(i)&gt;m)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让我们看看执行的效率<br><img src="/images/moshi/moshi2.jpg" alt="单例模式"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>单例模式是设计模式中最简单的一个，在以后的文章里我会继续讲解更多的模式设计，写代码不一定要堆砌各种模式，但是懂一点，在生产环境中使用，就会对产品有许多好的改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是设计模式里面最简单的一种模式，但是用处非常的广泛，用好了可以小幅度的提示整个页面的性能。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.jackfred.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="模式设计" scheme="http://www.jackfred.cn/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="读书笔记" scheme="http://www.jackfred.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
